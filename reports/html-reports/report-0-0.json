{"info":{"type":"runner","start":"2023-02-17T02:12:03.327Z","end":"2023-02-17T02:15:28.993Z","_duration":205666,"cid":"0-0","capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true,"sessionId":"182497dc6bf76af7c5a842405e9ac3c5"},"sanitizedCapabilities":"chrome.110_0_5481_77.macosx","config":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"info","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"enableDirectConnect":true,"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./features/**/*.feature"],"exclude":[],"suites":{},"rootDir":".","baseUrl":"https://snatchbot.me/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"cucumber","reporters":["spec",["html-nice",{"debug":false,"outputDir":"./reports/html-reports/","filename":"report.html","reportTitle":"SnatchBot Test Report","showInBrowser":false,"collapseTests":false,"useOnAfterCommandForScreenshot":true,"linkScreenshots":true}]],"services":["chromedriver"],"execArgv":[],"maxInstances":5,"maxInstancesPerCapability":100,"injectGlobals":true,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"onWorkerEnd":[],"before":[null],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"},"specs":["file:///Users/jimwatkins/Workspace/fart/features/login.feature"],"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","isMultiremote":false,"instanceOptions":{"182497dc6bf76af7c5a842405e9ac3c5":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"info","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"enableDirectConnect":true,"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./features/**/*.feature"],"exclude":[],"suites":{},"rootDir":".","baseUrl":"https://snatchbot.me/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"cucumber","reporters":["spec",["html-nice",{"debug":false,"outputDir":"./reports/html-reports/","filename":"report.html","reportTitle":"SnatchBot Test Report","showInBrowser":false,"collapseTests":false,"useOnAfterCommandForScreenshot":true,"linkScreenshots":true}]],"services":["chromedriver"],"execArgv":[],"maxInstances":5,"maxInstancesPerCapability":100,"injectGlobals":true,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"onWorkerEnd":[],"before":[null],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"}},"retry":0,"failures":0,"retries":0},"metrics":{"passed":44,"skipped":0,"failed":0,"duration":205666,"start":"2023-02-17T02:12:03.327Z","end":"2023-02-17T02:15:28Z"},"title":"SnatchBot Test Report","suites":[{"type":"feature","start":"2023-02-17T02:12:03.391Z","end":"2023-02-17T02:15:28.938Z","_duration":205539,"uid":"login.feature:1:1","cid":"0-0","file":"/Users/jimwatkins/Workspace/fart/features/login.feature","title":"The SnatchBot chat bot","tags":[],"tests":[],"hooks":[],"suites":[{"type":"scenario","start":"2023-02-17T02:12:03.401Z","end":"2023-02-17T02:12:14.855Z","_duration":11453,"uid":"0","cid":"0-0","file":"/Users/jimwatkins/Workspace/fart/features/login.feature","title":"As a user I can go to snatchbot.me and open the bot","fullTitle":"login.feature:1:1: As a user I can go to snatchbot.me and open the bot","tags":[],"tests":[{"type":"test","start":"2023-02-17T02:12:03.402Z","end":"2023-02-17T02:12:03.404Z","_duration":2,"uid":"36","cid":"0-0","title":"Given I am on the following url https://snatchbot.me/","fullTitle":"0: Given I am on the following url https://snatchbot.me/","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:12:03.404Z","end":"2023-02-17T02:12:12.791Z","_duration":9387,"uid":"37","cid":"0-0","title":"When I click on the SnatchBot chat bot","fullTitle":"0: When I click on the SnatchBot chat bot","output":[{"method":"POST","endpoint":"/session/:sessionId/window/maximize","body":{},"result":{"value":{"height":1079,"width":1661,"x":67,"y":38}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0ded4663-4404-476a-be4b-c9c52c56cf80"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"0ded4663-4404-476a-be4b-c9c52c56cf80","ELEMENT":"0ded4663-4404-476a-be4b-c9c52c56cf80"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"0ded4663-4404-476a-be4b-c9c52c56cf80","ELEMENT":"0ded4663-4404-476a-be4b-c9c52c56cf80"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"0ded4663-4404-476a-be4b-c9c52c56cf80","ELEMENT":"0ded4663-4404-476a-be4b-c9c52c56cf80"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"0ded4663-4404-476a-be4b-c9c52c56cf80","ELEMENT":"0ded4663-4404-476a-be4b-c9c52c56cf80"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0ded4663-4404-476a-be4b-c9c52c56cf80"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0ded4663-4404-476a-be4b-c9c52c56cf80/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0ded4663-4404-476a-be4b-c9c52c56cf80/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"db0c64b5-11f3-4996-8eeb-638ac67cfb94"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"db0c64b5-11f3-4996-8eeb-638ac67cfb94","element-6066-11e4-a52e-4f735466cecf":"db0c64b5-11f3-4996-8eeb-638ac67cfb94","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:12:12.791Z","end":"2023-02-17T02:12:14.853Z","_duration":2062,"uid":"38","cid":"0-0","title":"Then I am welcomed by the chatbot","fullTitle":"0: Then I am welcomed by the chatbot","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"db0c64b5-11f3-4996-8eeb-638ac67cfb94","element-6066-11e4-a52e-4f735466cecf":"db0c64b5-11f3-4996-8eeb-638ac67cfb94","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__body\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__body\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__body\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__body\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__body\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8c101852-abb4-462b-a1a7-9a907af2e89d"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"8c101852-abb4-462b-a1a7-9a907af2e89d","ELEMENT":"8c101852-abb4-462b-a1a7-9a907af2e89d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"8c101852-abb4-462b-a1a7-9a907af2e89d","ELEMENT":"8c101852-abb4-462b-a1a7-9a907af2e89d"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8c101852-abb4-462b-a1a7-9a907af2e89d"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8c101852-abb4-462b-a1a7-9a907af2e89d/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8c101852-abb4-462b-a1a7-9a907af2e89d/text","body":{},"result":{"value":"Hi  \nI'm Jamie, your friendly guide to chatbots and SnatchBot."},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0}],"hooks":[{"type":"hook","start":"2023-02-17T02:12:03.401Z","end":"2023-02-17T02:12:03.402Z","_duration":1,"uid":"105","cid":"0-0","title":"","parent":"0","errors":[]},{"type":"hook","start":"2023-02-17T02:12:14.854Z","end":"2023-02-17T02:12:14.854Z","_duration":0,"uid":"109","cid":"0-0","title":"","parent":"0","errors":[]}],"suites":[],"parent":"login.feature:1:1","hooksAndTests":[{"type":"hook","start":"2023-02-17T02:12:03.401Z","end":"2023-02-17T02:12:03.402Z","_duration":1,"uid":"105","cid":"0-0","title":"","parent":"0","errors":[]},{"type":"test","start":"2023-02-17T02:12:03.402Z","end":"2023-02-17T02:12:03.404Z","_duration":2,"uid":"36","cid":"0-0","title":"Given I am on the following url https://snatchbot.me/","fullTitle":"0: Given I am on the following url https://snatchbot.me/","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:12:03.404Z","end":"2023-02-17T02:12:12.791Z","_duration":9387,"uid":"37","cid":"0-0","title":"When I click on the SnatchBot chat bot","fullTitle":"0: When I click on the SnatchBot chat bot","output":[{"method":"POST","endpoint":"/session/:sessionId/window/maximize","body":{},"result":{"value":{"height":1079,"width":1661,"x":67,"y":38}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0ded4663-4404-476a-be4b-c9c52c56cf80"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"0ded4663-4404-476a-be4b-c9c52c56cf80","ELEMENT":"0ded4663-4404-476a-be4b-c9c52c56cf80"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"0ded4663-4404-476a-be4b-c9c52c56cf80","ELEMENT":"0ded4663-4404-476a-be4b-c9c52c56cf80"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"0ded4663-4404-476a-be4b-c9c52c56cf80","ELEMENT":"0ded4663-4404-476a-be4b-c9c52c56cf80"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"0ded4663-4404-476a-be4b-c9c52c56cf80","ELEMENT":"0ded4663-4404-476a-be4b-c9c52c56cf80"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0ded4663-4404-476a-be4b-c9c52c56cf80"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0ded4663-4404-476a-be4b-c9c52c56cf80/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0ded4663-4404-476a-be4b-c9c52c56cf80/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"db0c64b5-11f3-4996-8eeb-638ac67cfb94"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"db0c64b5-11f3-4996-8eeb-638ac67cfb94","element-6066-11e4-a52e-4f735466cecf":"db0c64b5-11f3-4996-8eeb-638ac67cfb94","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:12:12.791Z","end":"2023-02-17T02:12:14.853Z","_duration":2062,"uid":"38","cid":"0-0","title":"Then I am welcomed by the chatbot","fullTitle":"0: Then I am welcomed by the chatbot","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"db0c64b5-11f3-4996-8eeb-638ac67cfb94","element-6066-11e4-a52e-4f735466cecf":"db0c64b5-11f3-4996-8eeb-638ac67cfb94","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__body\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__body\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__body\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__body\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__body\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8c101852-abb4-462b-a1a7-9a907af2e89d"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"8c101852-abb4-462b-a1a7-9a907af2e89d","ELEMENT":"8c101852-abb4-462b-a1a7-9a907af2e89d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"8c101852-abb4-462b-a1a7-9a907af2e89d","ELEMENT":"8c101852-abb4-462b-a1a7-9a907af2e89d"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__body"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8c101852-abb4-462b-a1a7-9a907af2e89d"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8c101852-abb4-462b-a1a7-9a907af2e89d/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8c101852-abb4-462b-a1a7-9a907af2e89d/text","body":{},"result":{"value":"Hi  \nI'm Jamie, your friendly guide to chatbots and SnatchBot."},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"hook","start":"2023-02-17T02:12:14.854Z","end":"2023-02-17T02:12:14.854Z","_duration":0,"uid":"109","cid":"0-0","title":"","parent":"0","errors":[]}]},{"type":"scenario","start":"2023-02-17T02:12:14.855Z","end":"2023-02-17T02:12:34.079Z","_duration":19223,"uid":"1","cid":"0-0","file":"/Users/jimwatkins/Workspace/fart/features/login.feature","title":"As a user I want to see the conversation options the chatbot presents me","fullTitle":"login.feature:1:1: As a user I want to see the conversation options the chatbot presents me","tags":[],"tests":[{"type":"test","start":"2023-02-17T02:12:14.855Z","end":"2023-02-17T02:12:14.857Z","_duration":2,"uid":"40","cid":"0-0","title":"Given I am on the following url https://snatchbot.me/","fullTitle":"1: Given I am on the following url https://snatchbot.me/","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:12:14.857Z","end":"2023-02-17T02:12:17.440Z","_duration":2583,"uid":"41","cid":"0-0","title":"And I click on the SnatchBot chat bot","fullTitle":"1: And I click on the SnatchBot chat bot","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cf11e5fa-7f0e-4756-b6db-6a30dea87c09"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"cf11e5fa-7f0e-4756-b6db-6a30dea87c09","ELEMENT":"cf11e5fa-7f0e-4756-b6db-6a30dea87c09"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"cf11e5fa-7f0e-4756-b6db-6a30dea87c09","ELEMENT":"cf11e5fa-7f0e-4756-b6db-6a30dea87c09"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"cf11e5fa-7f0e-4756-b6db-6a30dea87c09","ELEMENT":"cf11e5fa-7f0e-4756-b6db-6a30dea87c09"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"cf11e5fa-7f0e-4756-b6db-6a30dea87c09","ELEMENT":"cf11e5fa-7f0e-4756-b6db-6a30dea87c09"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cf11e5fa-7f0e-4756-b6db-6a30dea87c09"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cf11e5fa-7f0e-4756-b6db-6a30dea87c09/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cf11e5fa-7f0e-4756-b6db-6a30dea87c09/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8b44f179-a5b8-430b-bf29-e9a3cf5af60f"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"8b44f179-a5b8-430b-bf29-e9a3cf5af60f","element-6066-11e4-a52e-4f735466cecf":"8b44f179-a5b8-430b-bf29-e9a3cf5af60f","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:12:17.441Z","end":"2023-02-17T02:12:31.498Z","_duration":14057,"uid":"42","cid":"0-0","title":"When I enter my name \"Frank\"","fullTitle":"1: When I enter my name \"Frank\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"8b44f179-a5b8-430b-bf29-e9a3cf5af60f","element-6066-11e4-a52e-4f735466cecf":"8b44f179-a5b8-430b-bf29-e9a3cf5af60f","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\"input#chat_input\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"5fec1076-2348-4fde-8eea-c3a22182811c"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"5fec1076-2348-4fde-8eea-c3a22182811c"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5fec1076-2348-4fde-8eea-c3a22182811c"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5fec1076-2348-4fde-8eea-c3a22182811c"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/clear","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/clear","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/value","body":{"text":"Frank"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/value","body":{"text":"Frank"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action1","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action1","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"07dd4be4-b198-497d-89bb-7b243b7bd54e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"07dd4be4-b198-497d-89bb-7b243b7bd54e","ELEMENT":"07dd4be4-b198-497d-89bb-7b243b7bd54e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"07dd4be4-b198-497d-89bb-7b243b7bd54e","ELEMENT":"07dd4be4-b198-497d-89bb-7b243b7bd54e"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"07dd4be4-b198-497d-89bb-7b243b7bd54e","ELEMENT":"07dd4be4-b198-497d-89bb-7b243b7bd54e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"07dd4be4-b198-497d-89bb-7b243b7bd54e","ELEMENT":"07dd4be4-b198-497d-89bb-7b243b7bd54e"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"07dd4be4-b198-497d-89bb-7b243b7bd54e"},{"element-6066-11e4-a52e-4f735466cecf":"84c51ad3-3589-4d57-805c-fcebbcde2f88"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/07dd4be4-b198-497d-89bb-7b243b7bd54e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/07dd4be4-b198-497d-89bb-7b243b7bd54e/text","body":{},"result":{"value":"Yes"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a288926e-9874-425c-8d62-48d407fc9371"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a288926e-9874-425c-8d62-48d407fc9371/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a288926e-9874-425c-8d62-48d407fc9371/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/07dd4be4-b198-497d-89bb-7b243b7bd54e/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/07dd4be4-b198-497d-89bb-7b243b7bd54e/rect","body":{},"result":{"value":{"height":40,"width":64,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action2","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"07dd4be4-b198-497d-89bb-7b243b7bd54e"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action2","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"07dd4be4-b198-497d-89bb-7b243b7bd54e"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/07dd4be4-b198-497d-89bb-7b243b7bd54e/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/07dd4be4-b198-497d-89bb-7b243b7bd54e/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/84c51ad3-3589-4d57-805c-fcebbcde2f88/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"69140841-8e9d-448a-8749-53853e3fda85"},{"element-6066-11e4-a52e-4f735466cecf":"4ff3891c-b5ae-43f3-8d91-67248822eb05"},{"element-6066-11e4-a52e-4f735466cecf":"a394513e-4901-4e91-b93b-e82dd774ba06"},{"element-6066-11e4-a52e-4f735466cecf":"5af3958b-911f-4ea1-8329-6598f97af466"},{"element-6066-11e4-a52e-4f735466cecf":"aa31b893-e490-49f0-9766-f1b180a1f976"},{"element-6066-11e4-a52e-4f735466cecf":"77e2ff58-ceb0-4b79-a27b-2f0de2e2aa15"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"69140841-8e9d-448a-8749-53853e3fda85"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/84c51ad3-3589-4d57-805c-fcebbcde2f88/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"69140841-8e9d-448a-8749-53853e3fda85"},{"element-6066-11e4-a52e-4f735466cecf":"4ff3891c-b5ae-43f3-8d91-67248822eb05"},{"element-6066-11e4-a52e-4f735466cecf":"a394513e-4901-4e91-b93b-e82dd774ba06"},{"element-6066-11e4-a52e-4f735466cecf":"5af3958b-911f-4ea1-8329-6598f97af466"},{"element-6066-11e4-a52e-4f735466cecf":"aa31b893-e490-49f0-9766-f1b180a1f976"},{"element-6066-11e4-a52e-4f735466cecf":"77e2ff58-ceb0-4b79-a27b-2f0de2e2aa15"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/84c51ad3-3589-4d57-805c-fcebbcde2f88/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"69140841-8e9d-448a-8749-53853e3fda85"},{"element-6066-11e4-a52e-4f735466cecf":"4ff3891c-b5ae-43f3-8d91-67248822eb05"},{"element-6066-11e4-a52e-4f735466cecf":"a394513e-4901-4e91-b93b-e82dd774ba06"},{"element-6066-11e4-a52e-4f735466cecf":"5af3958b-911f-4ea1-8329-6598f97af466"},{"element-6066-11e4-a52e-4f735466cecf":"aa31b893-e490-49f0-9766-f1b180a1f976"},{"element-6066-11e4-a52e-4f735466cecf":"77e2ff58-ceb0-4b79-a27b-2f0de2e2aa15"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/84c51ad3-3589-4d57-805c-fcebbcde2f88/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"69140841-8e9d-448a-8749-53853e3fda85"},{"element-6066-11e4-a52e-4f735466cecf":"4ff3891c-b5ae-43f3-8d91-67248822eb05"},{"element-6066-11e4-a52e-4f735466cecf":"a394513e-4901-4e91-b93b-e82dd774ba06"},{"element-6066-11e4-a52e-4f735466cecf":"5af3958b-911f-4ea1-8329-6598f97af466"},{"element-6066-11e4-a52e-4f735466cecf":"aa31b893-e490-49f0-9766-f1b180a1f976"},{"element-6066-11e4-a52e-4f735466cecf":"77e2ff58-ceb0-4b79-a27b-2f0de2e2aa15"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/4ff3891c-b5ae-43f3-8d91-67248822eb05/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/4ff3891c-b5ae-43f3-8d91-67248822eb05/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:12:31.498Z","end":"2023-02-17T02:12:34.078Z","_duration":2580,"uid":"43","cid":"0-0","title":"Then the chat bot's response contains conversation option Explain chatbots","fullTitle":"1: Then the chat bot's response contains conversation option Explain chatbots","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"69140841-8e9d-448a-8749-53853e3fda85"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"69140841-8e9d-448a-8749-53853e3fda85","ELEMENT":"69140841-8e9d-448a-8749-53853e3fda85"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"69140841-8e9d-448a-8749-53853e3fda85","ELEMENT":"69140841-8e9d-448a-8749-53853e3fda85"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"69140841-8e9d-448a-8749-53853e3fda85","ELEMENT":"69140841-8e9d-448a-8749-53853e3fda85"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"69140841-8e9d-448a-8749-53853e3fda85","ELEMENT":"69140841-8e9d-448a-8749-53853e3fda85"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"69140841-8e9d-448a-8749-53853e3fda85"},{"element-6066-11e4-a52e-4f735466cecf":"4ff3891c-b5ae-43f3-8d91-67248822eb05"},{"element-6066-11e4-a52e-4f735466cecf":"a394513e-4901-4e91-b93b-e82dd774ba06"},{"element-6066-11e4-a52e-4f735466cecf":"5af3958b-911f-4ea1-8329-6598f97af466"},{"element-6066-11e4-a52e-4f735466cecf":"aa31b893-e490-49f0-9766-f1b180a1f976"},{"element-6066-11e4-a52e-4f735466cecf":"77e2ff58-ceb0-4b79-a27b-2f0de2e2aa15"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/69140841-8e9d-448a-8749-53853e3fda85/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/69140841-8e9d-448a-8749-53853e3fda85/text","body":{},"result":{"value":"Explain chatbots"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/4ff3891c-b5ae-43f3-8d91-67248822eb05/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/4ff3891c-b5ae-43f3-8d91-67248822eb05/text","body":{},"result":{"value":"Make a chatbot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a394513e-4901-4e91-b93b-e82dd774ba06/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a394513e-4901-4e91-b93b-e82dd774ba06/text","body":{},"result":{"value":"Use cases"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5af3958b-911f-4ea1-8329-6598f97af466/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5af3958b-911f-4ea1-8329-6598f97af466/text","body":{},"result":{"value":"Features"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/aa31b893-e490-49f0-9766-f1b180a1f976/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/aa31b893-e490-49f0-9766-f1b180a1f976/text","body":{},"result":{"value":"Contact SnatchBot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/77e2ff58-ceb0-4b79-a27b-2f0de2e2aa15/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/77e2ff58-ceb0-4b79-a27b-2f0de2e2aa15/text","body":{},"result":{"value":"Costs"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0}],"hooks":[{"type":"hook","start":"2023-02-17T02:12:14.855Z","end":"2023-02-17T02:12:14.855Z","_duration":0,"uid":"111","cid":"0-0","title":"","parent":"1","errors":[]},{"type":"hook","start":"2023-02-17T02:12:34.078Z","end":"2023-02-17T02:12:34.078Z","_duration":0,"uid":"116","cid":"0-0","title":"","parent":"1","errors":[]}],"suites":[],"parent":"login.feature:1:1","hooksAndTests":[{"type":"hook","start":"2023-02-17T02:12:14.855Z","end":"2023-02-17T02:12:14.855Z","_duration":0,"uid":"111","cid":"0-0","title":"","parent":"1","errors":[]},{"type":"test","start":"2023-02-17T02:12:14.855Z","end":"2023-02-17T02:12:14.857Z","_duration":2,"uid":"40","cid":"0-0","title":"Given I am on the following url https://snatchbot.me/","fullTitle":"1: Given I am on the following url https://snatchbot.me/","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:12:14.857Z","end":"2023-02-17T02:12:17.440Z","_duration":2583,"uid":"41","cid":"0-0","title":"And I click on the SnatchBot chat bot","fullTitle":"1: And I click on the SnatchBot chat bot","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cf11e5fa-7f0e-4756-b6db-6a30dea87c09"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"cf11e5fa-7f0e-4756-b6db-6a30dea87c09","ELEMENT":"cf11e5fa-7f0e-4756-b6db-6a30dea87c09"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"cf11e5fa-7f0e-4756-b6db-6a30dea87c09","ELEMENT":"cf11e5fa-7f0e-4756-b6db-6a30dea87c09"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"cf11e5fa-7f0e-4756-b6db-6a30dea87c09","ELEMENT":"cf11e5fa-7f0e-4756-b6db-6a30dea87c09"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"cf11e5fa-7f0e-4756-b6db-6a30dea87c09","ELEMENT":"cf11e5fa-7f0e-4756-b6db-6a30dea87c09"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cf11e5fa-7f0e-4756-b6db-6a30dea87c09"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cf11e5fa-7f0e-4756-b6db-6a30dea87c09/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cf11e5fa-7f0e-4756-b6db-6a30dea87c09/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8b44f179-a5b8-430b-bf29-e9a3cf5af60f"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"8b44f179-a5b8-430b-bf29-e9a3cf5af60f","element-6066-11e4-a52e-4f735466cecf":"8b44f179-a5b8-430b-bf29-e9a3cf5af60f","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:12:17.441Z","end":"2023-02-17T02:12:31.498Z","_duration":14057,"uid":"42","cid":"0-0","title":"When I enter my name \"Frank\"","fullTitle":"1: When I enter my name \"Frank\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"8b44f179-a5b8-430b-bf29-e9a3cf5af60f","element-6066-11e4-a52e-4f735466cecf":"8b44f179-a5b8-430b-bf29-e9a3cf5af60f","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\"input#chat_input\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"5fec1076-2348-4fde-8eea-c3a22182811c"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"5fec1076-2348-4fde-8eea-c3a22182811c"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5fec1076-2348-4fde-8eea-c3a22182811c"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/enabled","body":{},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5fec1076-2348-4fde-8eea-c3a22182811c"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/clear","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/clear","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/value","body":{"text":"Frank"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5fec1076-2348-4fde-8eea-c3a22182811c/value","body":{"text":"Frank"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action1","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action1","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"07dd4be4-b198-497d-89bb-7b243b7bd54e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"07dd4be4-b198-497d-89bb-7b243b7bd54e","ELEMENT":"07dd4be4-b198-497d-89bb-7b243b7bd54e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"07dd4be4-b198-497d-89bb-7b243b7bd54e","ELEMENT":"07dd4be4-b198-497d-89bb-7b243b7bd54e"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"07dd4be4-b198-497d-89bb-7b243b7bd54e","ELEMENT":"07dd4be4-b198-497d-89bb-7b243b7bd54e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"07dd4be4-b198-497d-89bb-7b243b7bd54e","ELEMENT":"07dd4be4-b198-497d-89bb-7b243b7bd54e"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"07dd4be4-b198-497d-89bb-7b243b7bd54e"},{"element-6066-11e4-a52e-4f735466cecf":"84c51ad3-3589-4d57-805c-fcebbcde2f88"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/07dd4be4-b198-497d-89bb-7b243b7bd54e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/07dd4be4-b198-497d-89bb-7b243b7bd54e/text","body":{},"result":{"value":"Yes"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a288926e-9874-425c-8d62-48d407fc9371"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a288926e-9874-425c-8d62-48d407fc9371/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a288926e-9874-425c-8d62-48d407fc9371/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/07dd4be4-b198-497d-89bb-7b243b7bd54e/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/07dd4be4-b198-497d-89bb-7b243b7bd54e/rect","body":{},"result":{"value":{"height":40,"width":64,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action2","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"07dd4be4-b198-497d-89bb-7b243b7bd54e"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action2","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"07dd4be4-b198-497d-89bb-7b243b7bd54e"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/07dd4be4-b198-497d-89bb-7b243b7bd54e/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/07dd4be4-b198-497d-89bb-7b243b7bd54e/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/84c51ad3-3589-4d57-805c-fcebbcde2f88/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"69140841-8e9d-448a-8749-53853e3fda85"},{"element-6066-11e4-a52e-4f735466cecf":"4ff3891c-b5ae-43f3-8d91-67248822eb05"},{"element-6066-11e4-a52e-4f735466cecf":"a394513e-4901-4e91-b93b-e82dd774ba06"},{"element-6066-11e4-a52e-4f735466cecf":"5af3958b-911f-4ea1-8329-6598f97af466"},{"element-6066-11e4-a52e-4f735466cecf":"aa31b893-e490-49f0-9766-f1b180a1f976"},{"element-6066-11e4-a52e-4f735466cecf":"77e2ff58-ceb0-4b79-a27b-2f0de2e2aa15"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"69140841-8e9d-448a-8749-53853e3fda85"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/84c51ad3-3589-4d57-805c-fcebbcde2f88/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"69140841-8e9d-448a-8749-53853e3fda85"},{"element-6066-11e4-a52e-4f735466cecf":"4ff3891c-b5ae-43f3-8d91-67248822eb05"},{"element-6066-11e4-a52e-4f735466cecf":"a394513e-4901-4e91-b93b-e82dd774ba06"},{"element-6066-11e4-a52e-4f735466cecf":"5af3958b-911f-4ea1-8329-6598f97af466"},{"element-6066-11e4-a52e-4f735466cecf":"aa31b893-e490-49f0-9766-f1b180a1f976"},{"element-6066-11e4-a52e-4f735466cecf":"77e2ff58-ceb0-4b79-a27b-2f0de2e2aa15"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/84c51ad3-3589-4d57-805c-fcebbcde2f88/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"69140841-8e9d-448a-8749-53853e3fda85"},{"element-6066-11e4-a52e-4f735466cecf":"4ff3891c-b5ae-43f3-8d91-67248822eb05"},{"element-6066-11e4-a52e-4f735466cecf":"a394513e-4901-4e91-b93b-e82dd774ba06"},{"element-6066-11e4-a52e-4f735466cecf":"5af3958b-911f-4ea1-8329-6598f97af466"},{"element-6066-11e4-a52e-4f735466cecf":"aa31b893-e490-49f0-9766-f1b180a1f976"},{"element-6066-11e4-a52e-4f735466cecf":"77e2ff58-ceb0-4b79-a27b-2f0de2e2aa15"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/84c51ad3-3589-4d57-805c-fcebbcde2f88/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"69140841-8e9d-448a-8749-53853e3fda85"},{"element-6066-11e4-a52e-4f735466cecf":"4ff3891c-b5ae-43f3-8d91-67248822eb05"},{"element-6066-11e4-a52e-4f735466cecf":"a394513e-4901-4e91-b93b-e82dd774ba06"},{"element-6066-11e4-a52e-4f735466cecf":"5af3958b-911f-4ea1-8329-6598f97af466"},{"element-6066-11e4-a52e-4f735466cecf":"aa31b893-e490-49f0-9766-f1b180a1f976"},{"element-6066-11e4-a52e-4f735466cecf":"77e2ff58-ceb0-4b79-a27b-2f0de2e2aa15"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/4ff3891c-b5ae-43f3-8d91-67248822eb05/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/4ff3891c-b5ae-43f3-8d91-67248822eb05/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:12:31.498Z","end":"2023-02-17T02:12:34.078Z","_duration":2580,"uid":"43","cid":"0-0","title":"Then the chat bot's response contains conversation option Explain chatbots","fullTitle":"1: Then the chat bot's response contains conversation option Explain chatbots","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"69140841-8e9d-448a-8749-53853e3fda85"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"69140841-8e9d-448a-8749-53853e3fda85","ELEMENT":"69140841-8e9d-448a-8749-53853e3fda85"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"69140841-8e9d-448a-8749-53853e3fda85","ELEMENT":"69140841-8e9d-448a-8749-53853e3fda85"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"69140841-8e9d-448a-8749-53853e3fda85","ELEMENT":"69140841-8e9d-448a-8749-53853e3fda85"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"69140841-8e9d-448a-8749-53853e3fda85","ELEMENT":"69140841-8e9d-448a-8749-53853e3fda85"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"69140841-8e9d-448a-8749-53853e3fda85"},{"element-6066-11e4-a52e-4f735466cecf":"4ff3891c-b5ae-43f3-8d91-67248822eb05"},{"element-6066-11e4-a52e-4f735466cecf":"a394513e-4901-4e91-b93b-e82dd774ba06"},{"element-6066-11e4-a52e-4f735466cecf":"5af3958b-911f-4ea1-8329-6598f97af466"},{"element-6066-11e4-a52e-4f735466cecf":"aa31b893-e490-49f0-9766-f1b180a1f976"},{"element-6066-11e4-a52e-4f735466cecf":"77e2ff58-ceb0-4b79-a27b-2f0de2e2aa15"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/69140841-8e9d-448a-8749-53853e3fda85/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/69140841-8e9d-448a-8749-53853e3fda85/text","body":{},"result":{"value":"Explain chatbots"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/4ff3891c-b5ae-43f3-8d91-67248822eb05/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/4ff3891c-b5ae-43f3-8d91-67248822eb05/text","body":{},"result":{"value":"Make a chatbot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a394513e-4901-4e91-b93b-e82dd774ba06/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a394513e-4901-4e91-b93b-e82dd774ba06/text","body":{},"result":{"value":"Use cases"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5af3958b-911f-4ea1-8329-6598f97af466/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5af3958b-911f-4ea1-8329-6598f97af466/text","body":{},"result":{"value":"Features"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/aa31b893-e490-49f0-9766-f1b180a1f976/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/aa31b893-e490-49f0-9766-f1b180a1f976/text","body":{},"result":{"value":"Contact SnatchBot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/77e2ff58-ceb0-4b79-a27b-2f0de2e2aa15/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/77e2ff58-ceb0-4b79-a27b-2f0de2e2aa15/text","body":{},"result":{"value":"Costs"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0},{"type":"hook","start":"2023-02-17T02:12:34.078Z","end":"2023-02-17T02:12:34.078Z","_duration":0,"uid":"116","cid":"0-0","title":"","parent":"1","errors":[]}]},{"type":"scenario","start":"2023-02-17T02:12:34.079Z","end":"2023-02-17T02:12:53.227Z","_duration":19147,"uid":"2","cid":"0-0","file":"/Users/jimwatkins/Workspace/fart/features/login.feature","title":"As a user I want to see the conversation options the chatbot presents me","fullTitle":"login.feature:1:1: As a user I want to see the conversation options the chatbot presents me","tags":[],"tests":[{"type":"test","start":"2023-02-17T02:12:34.080Z","end":"2023-02-17T02:12:34.080Z","_duration":0,"uid":"45","cid":"0-0","title":"Given I am on the following url https://snatchbot.me/","fullTitle":"2: Given I am on the following url https://snatchbot.me/","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:12:34.080Z","end":"2023-02-17T02:12:36.664Z","_duration":2584,"uid":"46","cid":"0-0","title":"And I click on the SnatchBot chat bot","fullTitle":"2: And I click on the SnatchBot chat bot","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c319eff2-9850-4bce-baa7-a6278aa81c97"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"c319eff2-9850-4bce-baa7-a6278aa81c97","ELEMENT":"c319eff2-9850-4bce-baa7-a6278aa81c97"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"c319eff2-9850-4bce-baa7-a6278aa81c97","ELEMENT":"c319eff2-9850-4bce-baa7-a6278aa81c97"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"c319eff2-9850-4bce-baa7-a6278aa81c97","ELEMENT":"c319eff2-9850-4bce-baa7-a6278aa81c97"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"c319eff2-9850-4bce-baa7-a6278aa81c97","ELEMENT":"c319eff2-9850-4bce-baa7-a6278aa81c97"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c319eff2-9850-4bce-baa7-a6278aa81c97"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c319eff2-9850-4bce-baa7-a6278aa81c97/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c319eff2-9850-4bce-baa7-a6278aa81c97/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2a1a95e9-b9c1-4dcc-843f-62a83ca15a7c"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"2a1a95e9-b9c1-4dcc-843f-62a83ca15a7c","element-6066-11e4-a52e-4f735466cecf":"2a1a95e9-b9c1-4dcc-843f-62a83ca15a7c","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:12:36.664Z","end":"2023-02-17T02:12:50.648Z","_duration":13984,"uid":"47","cid":"0-0","title":"When I enter my name \"Frank\"","fullTitle":"2: When I enter my name \"Frank\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"2a1a95e9-b9c1-4dcc-843f-62a83ca15a7c","element-6066-11e4-a52e-4f735466cecf":"2a1a95e9-b9c1-4dcc-843f-62a83ca15a7c","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\"input#chat_input\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/clear","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/clear","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/value","body":{"text":"Frank"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/value","body":{"text":"Frank"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action3","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action3","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5","ELEMENT":"4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5","ELEMENT":"4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5","ELEMENT":"4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5","ELEMENT":"4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5"},{"element-6066-11e4-a52e-4f735466cecf":"27171f37-7248-48a2-be0d-59d5e3a70b0b"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5/text","body":{},"result":{"value":"Yes"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1a198167-928c-475d-a770-9bcdfeefe610"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1a198167-928c-475d-a770-9bcdfeefe610/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1a198167-928c-475d-a770-9bcdfeefe610/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5/rect","body":{},"result":{"value":{"height":40,"width":64,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action4","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action4","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/27171f37-7248-48a2-be0d-59d5e3a70b0b/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"2371f809-a293-4710-ac8a-e83d943b74c2"},{"element-6066-11e4-a52e-4f735466cecf":"02b59aa6-48b6-4637-b3e5-c3a871346114"},{"element-6066-11e4-a52e-4f735466cecf":"b1ef223a-c97d-4077-95ba-08897a312de4"},{"element-6066-11e4-a52e-4f735466cecf":"e706057a-4ef4-47e4-ad61-47ffaa1affb3"},{"element-6066-11e4-a52e-4f735466cecf":"96a9e17e-5271-426c-ba27-30e5e33b43fb"},{"element-6066-11e4-a52e-4f735466cecf":"1a9fc392-4fe3-43b3-b564-52c497a1109d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2371f809-a293-4710-ac8a-e83d943b74c2"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/27171f37-7248-48a2-be0d-59d5e3a70b0b/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"2371f809-a293-4710-ac8a-e83d943b74c2"},{"element-6066-11e4-a52e-4f735466cecf":"02b59aa6-48b6-4637-b3e5-c3a871346114"},{"element-6066-11e4-a52e-4f735466cecf":"b1ef223a-c97d-4077-95ba-08897a312de4"},{"element-6066-11e4-a52e-4f735466cecf":"e706057a-4ef4-47e4-ad61-47ffaa1affb3"},{"element-6066-11e4-a52e-4f735466cecf":"96a9e17e-5271-426c-ba27-30e5e33b43fb"},{"element-6066-11e4-a52e-4f735466cecf":"1a9fc392-4fe3-43b3-b564-52c497a1109d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/27171f37-7248-48a2-be0d-59d5e3a70b0b/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"2371f809-a293-4710-ac8a-e83d943b74c2"},{"element-6066-11e4-a52e-4f735466cecf":"02b59aa6-48b6-4637-b3e5-c3a871346114"},{"element-6066-11e4-a52e-4f735466cecf":"b1ef223a-c97d-4077-95ba-08897a312de4"},{"element-6066-11e4-a52e-4f735466cecf":"e706057a-4ef4-47e4-ad61-47ffaa1affb3"},{"element-6066-11e4-a52e-4f735466cecf":"96a9e17e-5271-426c-ba27-30e5e33b43fb"},{"element-6066-11e4-a52e-4f735466cecf":"1a9fc392-4fe3-43b3-b564-52c497a1109d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/27171f37-7248-48a2-be0d-59d5e3a70b0b/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"2371f809-a293-4710-ac8a-e83d943b74c2"},{"element-6066-11e4-a52e-4f735466cecf":"02b59aa6-48b6-4637-b3e5-c3a871346114"},{"element-6066-11e4-a52e-4f735466cecf":"b1ef223a-c97d-4077-95ba-08897a312de4"},{"element-6066-11e4-a52e-4f735466cecf":"e706057a-4ef4-47e4-ad61-47ffaa1affb3"},{"element-6066-11e4-a52e-4f735466cecf":"96a9e17e-5271-426c-ba27-30e5e33b43fb"},{"element-6066-11e4-a52e-4f735466cecf":"1a9fc392-4fe3-43b3-b564-52c497a1109d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/02b59aa6-48b6-4637-b3e5-c3a871346114/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/02b59aa6-48b6-4637-b3e5-c3a871346114/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:12:50.648Z","end":"2023-02-17T02:12:53.226Z","_duration":2578,"uid":"48","cid":"0-0","title":"Then the chat bot's response contains conversation option Make a chatbot","fullTitle":"2: Then the chat bot's response contains conversation option Make a chatbot","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2371f809-a293-4710-ac8a-e83d943b74c2"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2371f809-a293-4710-ac8a-e83d943b74c2","ELEMENT":"2371f809-a293-4710-ac8a-e83d943b74c2"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2371f809-a293-4710-ac8a-e83d943b74c2","ELEMENT":"2371f809-a293-4710-ac8a-e83d943b74c2"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2371f809-a293-4710-ac8a-e83d943b74c2","ELEMENT":"2371f809-a293-4710-ac8a-e83d943b74c2"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2371f809-a293-4710-ac8a-e83d943b74c2","ELEMENT":"2371f809-a293-4710-ac8a-e83d943b74c2"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"2371f809-a293-4710-ac8a-e83d943b74c2"},{"element-6066-11e4-a52e-4f735466cecf":"02b59aa6-48b6-4637-b3e5-c3a871346114"},{"element-6066-11e4-a52e-4f735466cecf":"b1ef223a-c97d-4077-95ba-08897a312de4"},{"element-6066-11e4-a52e-4f735466cecf":"e706057a-4ef4-47e4-ad61-47ffaa1affb3"},{"element-6066-11e4-a52e-4f735466cecf":"96a9e17e-5271-426c-ba27-30e5e33b43fb"},{"element-6066-11e4-a52e-4f735466cecf":"1a9fc392-4fe3-43b3-b564-52c497a1109d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2371f809-a293-4710-ac8a-e83d943b74c2/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/2371f809-a293-4710-ac8a-e83d943b74c2/text","body":{},"result":{"value":"Explain chatbots"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/02b59aa6-48b6-4637-b3e5-c3a871346114/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/02b59aa6-48b6-4637-b3e5-c3a871346114/text","body":{},"result":{"value":"Make a chatbot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b1ef223a-c97d-4077-95ba-08897a312de4/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b1ef223a-c97d-4077-95ba-08897a312de4/text","body":{},"result":{"value":"Use cases"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e706057a-4ef4-47e4-ad61-47ffaa1affb3/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e706057a-4ef4-47e4-ad61-47ffaa1affb3/text","body":{},"result":{"value":"Features"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/96a9e17e-5271-426c-ba27-30e5e33b43fb/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/96a9e17e-5271-426c-ba27-30e5e33b43fb/text","body":{},"result":{"value":"Contact SnatchBot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1a9fc392-4fe3-43b3-b564-52c497a1109d/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1a9fc392-4fe3-43b3-b564-52c497a1109d/text","body":{},"result":{"value":"Costs"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0}],"hooks":[{"type":"hook","start":"2023-02-17T02:12:34.079Z","end":"2023-02-17T02:12:34.080Z","_duration":1,"uid":"118","cid":"0-0","title":"","parent":"2","errors":[]},{"type":"hook","start":"2023-02-17T02:12:53.226Z","end":"2023-02-17T02:12:53.226Z","_duration":0,"uid":"123","cid":"0-0","title":"","parent":"2","errors":[]}],"suites":[],"parent":"login.feature:1:1","hooksAndTests":[{"type":"hook","start":"2023-02-17T02:12:34.079Z","end":"2023-02-17T02:12:34.080Z","_duration":1,"uid":"118","cid":"0-0","title":"","parent":"2","errors":[]},{"type":"test","start":"2023-02-17T02:12:34.080Z","end":"2023-02-17T02:12:34.080Z","_duration":0,"uid":"45","cid":"0-0","title":"Given I am on the following url https://snatchbot.me/","fullTitle":"2: Given I am on the following url https://snatchbot.me/","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:12:34.080Z","end":"2023-02-17T02:12:36.664Z","_duration":2584,"uid":"46","cid":"0-0","title":"And I click on the SnatchBot chat bot","fullTitle":"2: And I click on the SnatchBot chat bot","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c319eff2-9850-4bce-baa7-a6278aa81c97"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"c319eff2-9850-4bce-baa7-a6278aa81c97","ELEMENT":"c319eff2-9850-4bce-baa7-a6278aa81c97"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"c319eff2-9850-4bce-baa7-a6278aa81c97","ELEMENT":"c319eff2-9850-4bce-baa7-a6278aa81c97"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"c319eff2-9850-4bce-baa7-a6278aa81c97","ELEMENT":"c319eff2-9850-4bce-baa7-a6278aa81c97"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"c319eff2-9850-4bce-baa7-a6278aa81c97","ELEMENT":"c319eff2-9850-4bce-baa7-a6278aa81c97"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c319eff2-9850-4bce-baa7-a6278aa81c97"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c319eff2-9850-4bce-baa7-a6278aa81c97/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c319eff2-9850-4bce-baa7-a6278aa81c97/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2a1a95e9-b9c1-4dcc-843f-62a83ca15a7c"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"2a1a95e9-b9c1-4dcc-843f-62a83ca15a7c","element-6066-11e4-a52e-4f735466cecf":"2a1a95e9-b9c1-4dcc-843f-62a83ca15a7c","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:12:36.664Z","end":"2023-02-17T02:12:50.648Z","_duration":13984,"uid":"47","cid":"0-0","title":"When I enter my name \"Frank\"","fullTitle":"2: When I enter my name \"Frank\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"2a1a95e9-b9c1-4dcc-843f-62a83ca15a7c","element-6066-11e4-a52e-4f735466cecf":"2a1a95e9-b9c1-4dcc-843f-62a83ca15a7c","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\"input#chat_input\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/enabled","body":{},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/clear","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/clear","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/value","body":{"text":"Frank"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c0bc2591-6ee6-4f7f-b934-fed3cb7f94c0/value","body":{"text":"Frank"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action3","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action3","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5","ELEMENT":"4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5","ELEMENT":"4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5","ELEMENT":"4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5","ELEMENT":"4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5"},{"element-6066-11e4-a52e-4f735466cecf":"27171f37-7248-48a2-be0d-59d5e3a70b0b"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5/text","body":{},"result":{"value":"Yes"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1a198167-928c-475d-a770-9bcdfeefe610"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1a198167-928c-475d-a770-9bcdfeefe610/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1a198167-928c-475d-a770-9bcdfeefe610/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5/rect","body":{},"result":{"value":{"height":40,"width":64,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action4","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action4","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4ecf5bab-6d08-45d4-bbe0-bf4a5249fba5/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/27171f37-7248-48a2-be0d-59d5e3a70b0b/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"2371f809-a293-4710-ac8a-e83d943b74c2"},{"element-6066-11e4-a52e-4f735466cecf":"02b59aa6-48b6-4637-b3e5-c3a871346114"},{"element-6066-11e4-a52e-4f735466cecf":"b1ef223a-c97d-4077-95ba-08897a312de4"},{"element-6066-11e4-a52e-4f735466cecf":"e706057a-4ef4-47e4-ad61-47ffaa1affb3"},{"element-6066-11e4-a52e-4f735466cecf":"96a9e17e-5271-426c-ba27-30e5e33b43fb"},{"element-6066-11e4-a52e-4f735466cecf":"1a9fc392-4fe3-43b3-b564-52c497a1109d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2371f809-a293-4710-ac8a-e83d943b74c2"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/27171f37-7248-48a2-be0d-59d5e3a70b0b/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"2371f809-a293-4710-ac8a-e83d943b74c2"},{"element-6066-11e4-a52e-4f735466cecf":"02b59aa6-48b6-4637-b3e5-c3a871346114"},{"element-6066-11e4-a52e-4f735466cecf":"b1ef223a-c97d-4077-95ba-08897a312de4"},{"element-6066-11e4-a52e-4f735466cecf":"e706057a-4ef4-47e4-ad61-47ffaa1affb3"},{"element-6066-11e4-a52e-4f735466cecf":"96a9e17e-5271-426c-ba27-30e5e33b43fb"},{"element-6066-11e4-a52e-4f735466cecf":"1a9fc392-4fe3-43b3-b564-52c497a1109d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/27171f37-7248-48a2-be0d-59d5e3a70b0b/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"2371f809-a293-4710-ac8a-e83d943b74c2"},{"element-6066-11e4-a52e-4f735466cecf":"02b59aa6-48b6-4637-b3e5-c3a871346114"},{"element-6066-11e4-a52e-4f735466cecf":"b1ef223a-c97d-4077-95ba-08897a312de4"},{"element-6066-11e4-a52e-4f735466cecf":"e706057a-4ef4-47e4-ad61-47ffaa1affb3"},{"element-6066-11e4-a52e-4f735466cecf":"96a9e17e-5271-426c-ba27-30e5e33b43fb"},{"element-6066-11e4-a52e-4f735466cecf":"1a9fc392-4fe3-43b3-b564-52c497a1109d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/27171f37-7248-48a2-be0d-59d5e3a70b0b/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"2371f809-a293-4710-ac8a-e83d943b74c2"},{"element-6066-11e4-a52e-4f735466cecf":"02b59aa6-48b6-4637-b3e5-c3a871346114"},{"element-6066-11e4-a52e-4f735466cecf":"b1ef223a-c97d-4077-95ba-08897a312de4"},{"element-6066-11e4-a52e-4f735466cecf":"e706057a-4ef4-47e4-ad61-47ffaa1affb3"},{"element-6066-11e4-a52e-4f735466cecf":"96a9e17e-5271-426c-ba27-30e5e33b43fb"},{"element-6066-11e4-a52e-4f735466cecf":"1a9fc392-4fe3-43b3-b564-52c497a1109d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/02b59aa6-48b6-4637-b3e5-c3a871346114/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/02b59aa6-48b6-4637-b3e5-c3a871346114/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:12:50.648Z","end":"2023-02-17T02:12:53.226Z","_duration":2578,"uid":"48","cid":"0-0","title":"Then the chat bot's response contains conversation option Make a chatbot","fullTitle":"2: Then the chat bot's response contains conversation option Make a chatbot","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2371f809-a293-4710-ac8a-e83d943b74c2"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2371f809-a293-4710-ac8a-e83d943b74c2","ELEMENT":"2371f809-a293-4710-ac8a-e83d943b74c2"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2371f809-a293-4710-ac8a-e83d943b74c2","ELEMENT":"2371f809-a293-4710-ac8a-e83d943b74c2"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2371f809-a293-4710-ac8a-e83d943b74c2","ELEMENT":"2371f809-a293-4710-ac8a-e83d943b74c2"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2371f809-a293-4710-ac8a-e83d943b74c2","ELEMENT":"2371f809-a293-4710-ac8a-e83d943b74c2"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"2371f809-a293-4710-ac8a-e83d943b74c2"},{"element-6066-11e4-a52e-4f735466cecf":"02b59aa6-48b6-4637-b3e5-c3a871346114"},{"element-6066-11e4-a52e-4f735466cecf":"b1ef223a-c97d-4077-95ba-08897a312de4"},{"element-6066-11e4-a52e-4f735466cecf":"e706057a-4ef4-47e4-ad61-47ffaa1affb3"},{"element-6066-11e4-a52e-4f735466cecf":"96a9e17e-5271-426c-ba27-30e5e33b43fb"},{"element-6066-11e4-a52e-4f735466cecf":"1a9fc392-4fe3-43b3-b564-52c497a1109d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2371f809-a293-4710-ac8a-e83d943b74c2/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/2371f809-a293-4710-ac8a-e83d943b74c2/text","body":{},"result":{"value":"Explain chatbots"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/02b59aa6-48b6-4637-b3e5-c3a871346114/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/02b59aa6-48b6-4637-b3e5-c3a871346114/text","body":{},"result":{"value":"Make a chatbot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b1ef223a-c97d-4077-95ba-08897a312de4/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b1ef223a-c97d-4077-95ba-08897a312de4/text","body":{},"result":{"value":"Use cases"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e706057a-4ef4-47e4-ad61-47ffaa1affb3/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e706057a-4ef4-47e4-ad61-47ffaa1affb3/text","body":{},"result":{"value":"Features"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/96a9e17e-5271-426c-ba27-30e5e33b43fb/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/96a9e17e-5271-426c-ba27-30e5e33b43fb/text","body":{},"result":{"value":"Contact SnatchBot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1a9fc392-4fe3-43b3-b564-52c497a1109d/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1a9fc392-4fe3-43b3-b564-52c497a1109d/text","body":{},"result":{"value":"Costs"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0},{"type":"hook","start":"2023-02-17T02:12:53.226Z","end":"2023-02-17T02:12:53.226Z","_duration":0,"uid":"123","cid":"0-0","title":"","parent":"2","errors":[]}]},{"type":"scenario","start":"2023-02-17T02:12:53.227Z","end":"2023-02-17T02:13:12.410Z","_duration":19183,"uid":"3","cid":"0-0","file":"/Users/jimwatkins/Workspace/fart/features/login.feature","title":"As a user I want to see the conversation options the chatbot presents me","fullTitle":"login.feature:1:1: As a user I want to see the conversation options the chatbot presents me","tags":[],"tests":[{"type":"test","start":"2023-02-17T02:12:53.227Z","end":"2023-02-17T02:12:53.228Z","_duration":1,"uid":"50","cid":"0-0","title":"Given I am on the following url https://snatchbot.me/","fullTitle":"3: Given I am on the following url https://snatchbot.me/","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"3","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:12:53.228Z","end":"2023-02-17T02:12:55.814Z","_duration":2586,"uid":"51","cid":"0-0","title":"And I click on the SnatchBot chat bot","fullTitle":"3: And I click on the SnatchBot chat bot","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"828afbed-f0da-47a1-b55c-cd68d7ecb7e6"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"828afbed-f0da-47a1-b55c-cd68d7ecb7e6","ELEMENT":"828afbed-f0da-47a1-b55c-cd68d7ecb7e6"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"828afbed-f0da-47a1-b55c-cd68d7ecb7e6","ELEMENT":"828afbed-f0da-47a1-b55c-cd68d7ecb7e6"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"828afbed-f0da-47a1-b55c-cd68d7ecb7e6","ELEMENT":"828afbed-f0da-47a1-b55c-cd68d7ecb7e6"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"828afbed-f0da-47a1-b55c-cd68d7ecb7e6","ELEMENT":"828afbed-f0da-47a1-b55c-cd68d7ecb7e6"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"828afbed-f0da-47a1-b55c-cd68d7ecb7e6"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/828afbed-f0da-47a1-b55c-cd68d7ecb7e6/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/828afbed-f0da-47a1-b55c-cd68d7ecb7e6/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c90d602d-c5ae-428f-8caa-7e60c43efbaf"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"c90d602d-c5ae-428f-8caa-7e60c43efbaf","element-6066-11e4-a52e-4f735466cecf":"c90d602d-c5ae-428f-8caa-7e60c43efbaf","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"3","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:12:55.814Z","end":"2023-02-17T02:13:09.843Z","_duration":14029,"uid":"52","cid":"0-0","title":"When I enter my name \"Frank\"","fullTitle":"3: When I enter my name \"Frank\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"c90d602d-c5ae-428f-8caa-7e60c43efbaf","element-6066-11e4-a52e-4f735466cecf":"c90d602d-c5ae-428f-8caa-7e60c43efbaf","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\"input#chat_input\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"80bc076a-f8a5-47aa-9e24-3558e8ef4a6a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"80bc076a-f8a5-47aa-9e24-3558e8ef4a6a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"80bc076a-f8a5-47aa-9e24-3558e8ef4a6a"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"80bc076a-f8a5-47aa-9e24-3558e8ef4a6a"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/clear","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/clear","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/value","body":{"text":"Frank"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/value","body":{"text":"Frank"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action5","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action5","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d4e17b72-bd30-4cab-8128-cbad8b5899bf"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4e17b72-bd30-4cab-8128-cbad8b5899bf","ELEMENT":"d4e17b72-bd30-4cab-8128-cbad8b5899bf"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4e17b72-bd30-4cab-8128-cbad8b5899bf","ELEMENT":"d4e17b72-bd30-4cab-8128-cbad8b5899bf"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4e17b72-bd30-4cab-8128-cbad8b5899bf","ELEMENT":"d4e17b72-bd30-4cab-8128-cbad8b5899bf"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4e17b72-bd30-4cab-8128-cbad8b5899bf","ELEMENT":"d4e17b72-bd30-4cab-8128-cbad8b5899bf"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"d4e17b72-bd30-4cab-8128-cbad8b5899bf"},{"element-6066-11e4-a52e-4f735466cecf":"59572254-cf19-4571-a83c-9c47172cdc7e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d4e17b72-bd30-4cab-8128-cbad8b5899bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d4e17b72-bd30-4cab-8128-cbad8b5899bf/text","body":{},"result":{"value":"Yes"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3ae5d46e-9185-4f25-bd0a-3fcd98323e61"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3ae5d46e-9185-4f25-bd0a-3fcd98323e61/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3ae5d46e-9185-4f25-bd0a-3fcd98323e61/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d4e17b72-bd30-4cab-8128-cbad8b5899bf/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d4e17b72-bd30-4cab-8128-cbad8b5899bf/rect","body":{},"result":{"value":{"height":40,"width":64,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action6","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"d4e17b72-bd30-4cab-8128-cbad8b5899bf"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action6","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"d4e17b72-bd30-4cab-8128-cbad8b5899bf"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d4e17b72-bd30-4cab-8128-cbad8b5899bf/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d4e17b72-bd30-4cab-8128-cbad8b5899bf/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/59572254-cf19-4571-a83c-9c47172cdc7e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fdb32a8b-e51c-4a0f-ad2b-327f28374496"},{"element-6066-11e4-a52e-4f735466cecf":"f9b7f0f6-2591-4b7d-9a1d-66e36ad35df2"},{"element-6066-11e4-a52e-4f735466cecf":"64f1b175-8fc8-4d1a-ac6c-9d689977a512"},{"element-6066-11e4-a52e-4f735466cecf":"68c63e0a-343e-4df1-be42-c2de3a52d485"},{"element-6066-11e4-a52e-4f735466cecf":"e9c65b2f-3540-4b8c-9d78-6de83e3a2737"},{"element-6066-11e4-a52e-4f735466cecf":"b57f030a-8d9e-4a8e-bb7b-8ae5cb12d8df"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fdb32a8b-e51c-4a0f-ad2b-327f28374496"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/59572254-cf19-4571-a83c-9c47172cdc7e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fdb32a8b-e51c-4a0f-ad2b-327f28374496"},{"element-6066-11e4-a52e-4f735466cecf":"f9b7f0f6-2591-4b7d-9a1d-66e36ad35df2"},{"element-6066-11e4-a52e-4f735466cecf":"64f1b175-8fc8-4d1a-ac6c-9d689977a512"},{"element-6066-11e4-a52e-4f735466cecf":"68c63e0a-343e-4df1-be42-c2de3a52d485"},{"element-6066-11e4-a52e-4f735466cecf":"e9c65b2f-3540-4b8c-9d78-6de83e3a2737"},{"element-6066-11e4-a52e-4f735466cecf":"b57f030a-8d9e-4a8e-bb7b-8ae5cb12d8df"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/59572254-cf19-4571-a83c-9c47172cdc7e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fdb32a8b-e51c-4a0f-ad2b-327f28374496"},{"element-6066-11e4-a52e-4f735466cecf":"f9b7f0f6-2591-4b7d-9a1d-66e36ad35df2"},{"element-6066-11e4-a52e-4f735466cecf":"64f1b175-8fc8-4d1a-ac6c-9d689977a512"},{"element-6066-11e4-a52e-4f735466cecf":"68c63e0a-343e-4df1-be42-c2de3a52d485"},{"element-6066-11e4-a52e-4f735466cecf":"e9c65b2f-3540-4b8c-9d78-6de83e3a2737"},{"element-6066-11e4-a52e-4f735466cecf":"b57f030a-8d9e-4a8e-bb7b-8ae5cb12d8df"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/59572254-cf19-4571-a83c-9c47172cdc7e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fdb32a8b-e51c-4a0f-ad2b-327f28374496"},{"element-6066-11e4-a52e-4f735466cecf":"f9b7f0f6-2591-4b7d-9a1d-66e36ad35df2"},{"element-6066-11e4-a52e-4f735466cecf":"64f1b175-8fc8-4d1a-ac6c-9d689977a512"},{"element-6066-11e4-a52e-4f735466cecf":"68c63e0a-343e-4df1-be42-c2de3a52d485"},{"element-6066-11e4-a52e-4f735466cecf":"e9c65b2f-3540-4b8c-9d78-6de83e3a2737"},{"element-6066-11e4-a52e-4f735466cecf":"b57f030a-8d9e-4a8e-bb7b-8ae5cb12d8df"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f9b7f0f6-2591-4b7d-9a1d-66e36ad35df2/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f9b7f0f6-2591-4b7d-9a1d-66e36ad35df2/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"3","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:13:09.843Z","end":"2023-02-17T02:13:12.409Z","_duration":2566,"uid":"53","cid":"0-0","title":"Then the chat bot's response contains conversation option Use cases","fullTitle":"3: Then the chat bot's response contains conversation option Use cases","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fdb32a8b-e51c-4a0f-ad2b-327f28374496"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fdb32a8b-e51c-4a0f-ad2b-327f28374496","ELEMENT":"fdb32a8b-e51c-4a0f-ad2b-327f28374496"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fdb32a8b-e51c-4a0f-ad2b-327f28374496","ELEMENT":"fdb32a8b-e51c-4a0f-ad2b-327f28374496"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fdb32a8b-e51c-4a0f-ad2b-327f28374496","ELEMENT":"fdb32a8b-e51c-4a0f-ad2b-327f28374496"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fdb32a8b-e51c-4a0f-ad2b-327f28374496","ELEMENT":"fdb32a8b-e51c-4a0f-ad2b-327f28374496"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fdb32a8b-e51c-4a0f-ad2b-327f28374496"},{"element-6066-11e4-a52e-4f735466cecf":"f9b7f0f6-2591-4b7d-9a1d-66e36ad35df2"},{"element-6066-11e4-a52e-4f735466cecf":"64f1b175-8fc8-4d1a-ac6c-9d689977a512"},{"element-6066-11e4-a52e-4f735466cecf":"68c63e0a-343e-4df1-be42-c2de3a52d485"},{"element-6066-11e4-a52e-4f735466cecf":"e9c65b2f-3540-4b8c-9d78-6de83e3a2737"},{"element-6066-11e4-a52e-4f735466cecf":"b57f030a-8d9e-4a8e-bb7b-8ae5cb12d8df"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/fdb32a8b-e51c-4a0f-ad2b-327f28374496/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/fdb32a8b-e51c-4a0f-ad2b-327f28374496/text","body":{},"result":{"value":"Explain chatbots"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f9b7f0f6-2591-4b7d-9a1d-66e36ad35df2/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f9b7f0f6-2591-4b7d-9a1d-66e36ad35df2/text","body":{},"result":{"value":"Make a chatbot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/64f1b175-8fc8-4d1a-ac6c-9d689977a512/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/64f1b175-8fc8-4d1a-ac6c-9d689977a512/text","body":{},"result":{"value":"Use cases"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/68c63e0a-343e-4df1-be42-c2de3a52d485/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/68c63e0a-343e-4df1-be42-c2de3a52d485/text","body":{},"result":{"value":"Features"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e9c65b2f-3540-4b8c-9d78-6de83e3a2737/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e9c65b2f-3540-4b8c-9d78-6de83e3a2737/text","body":{},"result":{"value":"Contact SnatchBot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b57f030a-8d9e-4a8e-bb7b-8ae5cb12d8df/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b57f030a-8d9e-4a8e-bb7b-8ae5cb12d8df/text","body":{},"result":{"value":"Costs"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"3","state":"passed","events":[],"errorIndex":0}],"hooks":[{"type":"hook","start":"2023-02-17T02:12:53.227Z","end":"2023-02-17T02:12:53.227Z","_duration":0,"uid":"125","cid":"0-0","title":"","parent":"3","errors":[]},{"type":"hook","start":"2023-02-17T02:13:12.409Z","end":"2023-02-17T02:13:12.410Z","_duration":1,"uid":"130","cid":"0-0","title":"","parent":"3","errors":[]}],"suites":[],"parent":"login.feature:1:1","hooksAndTests":[{"type":"hook","start":"2023-02-17T02:12:53.227Z","end":"2023-02-17T02:12:53.227Z","_duration":0,"uid":"125","cid":"0-0","title":"","parent":"3","errors":[]},{"type":"test","start":"2023-02-17T02:12:53.227Z","end":"2023-02-17T02:12:53.228Z","_duration":1,"uid":"50","cid":"0-0","title":"Given I am on the following url https://snatchbot.me/","fullTitle":"3: Given I am on the following url https://snatchbot.me/","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"3","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:12:53.228Z","end":"2023-02-17T02:12:55.814Z","_duration":2586,"uid":"51","cid":"0-0","title":"And I click on the SnatchBot chat bot","fullTitle":"3: And I click on the SnatchBot chat bot","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"828afbed-f0da-47a1-b55c-cd68d7ecb7e6"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"828afbed-f0da-47a1-b55c-cd68d7ecb7e6","ELEMENT":"828afbed-f0da-47a1-b55c-cd68d7ecb7e6"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"828afbed-f0da-47a1-b55c-cd68d7ecb7e6","ELEMENT":"828afbed-f0da-47a1-b55c-cd68d7ecb7e6"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"828afbed-f0da-47a1-b55c-cd68d7ecb7e6","ELEMENT":"828afbed-f0da-47a1-b55c-cd68d7ecb7e6"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"828afbed-f0da-47a1-b55c-cd68d7ecb7e6","ELEMENT":"828afbed-f0da-47a1-b55c-cd68d7ecb7e6"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"828afbed-f0da-47a1-b55c-cd68d7ecb7e6"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/828afbed-f0da-47a1-b55c-cd68d7ecb7e6/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/828afbed-f0da-47a1-b55c-cd68d7ecb7e6/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c90d602d-c5ae-428f-8caa-7e60c43efbaf"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"c90d602d-c5ae-428f-8caa-7e60c43efbaf","element-6066-11e4-a52e-4f735466cecf":"c90d602d-c5ae-428f-8caa-7e60c43efbaf","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"3","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:12:55.814Z","end":"2023-02-17T02:13:09.843Z","_duration":14029,"uid":"52","cid":"0-0","title":"When I enter my name \"Frank\"","fullTitle":"3: When I enter my name \"Frank\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"c90d602d-c5ae-428f-8caa-7e60c43efbaf","element-6066-11e4-a52e-4f735466cecf":"c90d602d-c5ae-428f-8caa-7e60c43efbaf","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\"input#chat_input\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"80bc076a-f8a5-47aa-9e24-3558e8ef4a6a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"80bc076a-f8a5-47aa-9e24-3558e8ef4a6a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"80bc076a-f8a5-47aa-9e24-3558e8ef4a6a"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/enabled","body":{},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"80bc076a-f8a5-47aa-9e24-3558e8ef4a6a"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/clear","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/clear","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/value","body":{"text":"Frank"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/80bc076a-f8a5-47aa-9e24-3558e8ef4a6a/value","body":{"text":"Frank"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action5","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action5","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d4e17b72-bd30-4cab-8128-cbad8b5899bf"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4e17b72-bd30-4cab-8128-cbad8b5899bf","ELEMENT":"d4e17b72-bd30-4cab-8128-cbad8b5899bf"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4e17b72-bd30-4cab-8128-cbad8b5899bf","ELEMENT":"d4e17b72-bd30-4cab-8128-cbad8b5899bf"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4e17b72-bd30-4cab-8128-cbad8b5899bf","ELEMENT":"d4e17b72-bd30-4cab-8128-cbad8b5899bf"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4e17b72-bd30-4cab-8128-cbad8b5899bf","ELEMENT":"d4e17b72-bd30-4cab-8128-cbad8b5899bf"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"d4e17b72-bd30-4cab-8128-cbad8b5899bf"},{"element-6066-11e4-a52e-4f735466cecf":"59572254-cf19-4571-a83c-9c47172cdc7e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d4e17b72-bd30-4cab-8128-cbad8b5899bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d4e17b72-bd30-4cab-8128-cbad8b5899bf/text","body":{},"result":{"value":"Yes"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3ae5d46e-9185-4f25-bd0a-3fcd98323e61"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3ae5d46e-9185-4f25-bd0a-3fcd98323e61/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3ae5d46e-9185-4f25-bd0a-3fcd98323e61/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d4e17b72-bd30-4cab-8128-cbad8b5899bf/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d4e17b72-bd30-4cab-8128-cbad8b5899bf/rect","body":{},"result":{"value":{"height":40,"width":64,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action6","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"d4e17b72-bd30-4cab-8128-cbad8b5899bf"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action6","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"d4e17b72-bd30-4cab-8128-cbad8b5899bf"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d4e17b72-bd30-4cab-8128-cbad8b5899bf/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d4e17b72-bd30-4cab-8128-cbad8b5899bf/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/59572254-cf19-4571-a83c-9c47172cdc7e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fdb32a8b-e51c-4a0f-ad2b-327f28374496"},{"element-6066-11e4-a52e-4f735466cecf":"f9b7f0f6-2591-4b7d-9a1d-66e36ad35df2"},{"element-6066-11e4-a52e-4f735466cecf":"64f1b175-8fc8-4d1a-ac6c-9d689977a512"},{"element-6066-11e4-a52e-4f735466cecf":"68c63e0a-343e-4df1-be42-c2de3a52d485"},{"element-6066-11e4-a52e-4f735466cecf":"e9c65b2f-3540-4b8c-9d78-6de83e3a2737"},{"element-6066-11e4-a52e-4f735466cecf":"b57f030a-8d9e-4a8e-bb7b-8ae5cb12d8df"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fdb32a8b-e51c-4a0f-ad2b-327f28374496"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/59572254-cf19-4571-a83c-9c47172cdc7e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fdb32a8b-e51c-4a0f-ad2b-327f28374496"},{"element-6066-11e4-a52e-4f735466cecf":"f9b7f0f6-2591-4b7d-9a1d-66e36ad35df2"},{"element-6066-11e4-a52e-4f735466cecf":"64f1b175-8fc8-4d1a-ac6c-9d689977a512"},{"element-6066-11e4-a52e-4f735466cecf":"68c63e0a-343e-4df1-be42-c2de3a52d485"},{"element-6066-11e4-a52e-4f735466cecf":"e9c65b2f-3540-4b8c-9d78-6de83e3a2737"},{"element-6066-11e4-a52e-4f735466cecf":"b57f030a-8d9e-4a8e-bb7b-8ae5cb12d8df"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/59572254-cf19-4571-a83c-9c47172cdc7e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fdb32a8b-e51c-4a0f-ad2b-327f28374496"},{"element-6066-11e4-a52e-4f735466cecf":"f9b7f0f6-2591-4b7d-9a1d-66e36ad35df2"},{"element-6066-11e4-a52e-4f735466cecf":"64f1b175-8fc8-4d1a-ac6c-9d689977a512"},{"element-6066-11e4-a52e-4f735466cecf":"68c63e0a-343e-4df1-be42-c2de3a52d485"},{"element-6066-11e4-a52e-4f735466cecf":"e9c65b2f-3540-4b8c-9d78-6de83e3a2737"},{"element-6066-11e4-a52e-4f735466cecf":"b57f030a-8d9e-4a8e-bb7b-8ae5cb12d8df"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/59572254-cf19-4571-a83c-9c47172cdc7e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fdb32a8b-e51c-4a0f-ad2b-327f28374496"},{"element-6066-11e4-a52e-4f735466cecf":"f9b7f0f6-2591-4b7d-9a1d-66e36ad35df2"},{"element-6066-11e4-a52e-4f735466cecf":"64f1b175-8fc8-4d1a-ac6c-9d689977a512"},{"element-6066-11e4-a52e-4f735466cecf":"68c63e0a-343e-4df1-be42-c2de3a52d485"},{"element-6066-11e4-a52e-4f735466cecf":"e9c65b2f-3540-4b8c-9d78-6de83e3a2737"},{"element-6066-11e4-a52e-4f735466cecf":"b57f030a-8d9e-4a8e-bb7b-8ae5cb12d8df"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f9b7f0f6-2591-4b7d-9a1d-66e36ad35df2/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f9b7f0f6-2591-4b7d-9a1d-66e36ad35df2/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"3","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:13:09.843Z","end":"2023-02-17T02:13:12.409Z","_duration":2566,"uid":"53","cid":"0-0","title":"Then the chat bot's response contains conversation option Use cases","fullTitle":"3: Then the chat bot's response contains conversation option Use cases","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fdb32a8b-e51c-4a0f-ad2b-327f28374496"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fdb32a8b-e51c-4a0f-ad2b-327f28374496","ELEMENT":"fdb32a8b-e51c-4a0f-ad2b-327f28374496"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fdb32a8b-e51c-4a0f-ad2b-327f28374496","ELEMENT":"fdb32a8b-e51c-4a0f-ad2b-327f28374496"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fdb32a8b-e51c-4a0f-ad2b-327f28374496","ELEMENT":"fdb32a8b-e51c-4a0f-ad2b-327f28374496"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fdb32a8b-e51c-4a0f-ad2b-327f28374496","ELEMENT":"fdb32a8b-e51c-4a0f-ad2b-327f28374496"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fdb32a8b-e51c-4a0f-ad2b-327f28374496"},{"element-6066-11e4-a52e-4f735466cecf":"f9b7f0f6-2591-4b7d-9a1d-66e36ad35df2"},{"element-6066-11e4-a52e-4f735466cecf":"64f1b175-8fc8-4d1a-ac6c-9d689977a512"},{"element-6066-11e4-a52e-4f735466cecf":"68c63e0a-343e-4df1-be42-c2de3a52d485"},{"element-6066-11e4-a52e-4f735466cecf":"e9c65b2f-3540-4b8c-9d78-6de83e3a2737"},{"element-6066-11e4-a52e-4f735466cecf":"b57f030a-8d9e-4a8e-bb7b-8ae5cb12d8df"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/fdb32a8b-e51c-4a0f-ad2b-327f28374496/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/fdb32a8b-e51c-4a0f-ad2b-327f28374496/text","body":{},"result":{"value":"Explain chatbots"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f9b7f0f6-2591-4b7d-9a1d-66e36ad35df2/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f9b7f0f6-2591-4b7d-9a1d-66e36ad35df2/text","body":{},"result":{"value":"Make a chatbot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/64f1b175-8fc8-4d1a-ac6c-9d689977a512/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/64f1b175-8fc8-4d1a-ac6c-9d689977a512/text","body":{},"result":{"value":"Use cases"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/68c63e0a-343e-4df1-be42-c2de3a52d485/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/68c63e0a-343e-4df1-be42-c2de3a52d485/text","body":{},"result":{"value":"Features"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e9c65b2f-3540-4b8c-9d78-6de83e3a2737/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e9c65b2f-3540-4b8c-9d78-6de83e3a2737/text","body":{},"result":{"value":"Contact SnatchBot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b57f030a-8d9e-4a8e-bb7b-8ae5cb12d8df/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b57f030a-8d9e-4a8e-bb7b-8ae5cb12d8df/text","body":{},"result":{"value":"Costs"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"3","state":"passed","events":[],"errorIndex":0},{"type":"hook","start":"2023-02-17T02:13:12.409Z","end":"2023-02-17T02:13:12.410Z","_duration":1,"uid":"130","cid":"0-0","title":"","parent":"3","errors":[]}]},{"type":"scenario","start":"2023-02-17T02:13:12.410Z","end":"2023-02-17T02:13:33.058Z","_duration":20647,"uid":"4","cid":"0-0","file":"/Users/jimwatkins/Workspace/fart/features/login.feature","title":"As a user I want to see the conversation options the chatbot presents me","fullTitle":"login.feature:1:1: As a user I want to see the conversation options the chatbot presents me","tags":[],"tests":[{"type":"test","start":"2023-02-17T02:13:12.411Z","end":"2023-02-17T02:13:12.411Z","_duration":0,"uid":"55","cid":"0-0","title":"Given I am on the following url https://snatchbot.me/","fullTitle":"4: Given I am on the following url https://snatchbot.me/","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"4","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:13:12.411Z","end":"2023-02-17T02:13:15.466Z","_duration":3055,"uid":"56","cid":"0-0","title":"And I click on the SnatchBot chat bot","fullTitle":"4: And I click on the SnatchBot chat bot","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3185cb14-5ced-48b0-8c9f-95fa8c5337d4"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3185cb14-5ced-48b0-8c9f-95fa8c5337d4","ELEMENT":"3185cb14-5ced-48b0-8c9f-95fa8c5337d4"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3185cb14-5ced-48b0-8c9f-95fa8c5337d4","ELEMENT":"3185cb14-5ced-48b0-8c9f-95fa8c5337d4"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3185cb14-5ced-48b0-8c9f-95fa8c5337d4","ELEMENT":"3185cb14-5ced-48b0-8c9f-95fa8c5337d4"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3185cb14-5ced-48b0-8c9f-95fa8c5337d4","ELEMENT":"3185cb14-5ced-48b0-8c9f-95fa8c5337d4"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3185cb14-5ced-48b0-8c9f-95fa8c5337d4"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/3185cb14-5ced-48b0-8c9f-95fa8c5337d4/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/3185cb14-5ced-48b0-8c9f-95fa8c5337d4/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2d1bd704-40fc-4d6d-8aae-22fec400189e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"2d1bd704-40fc-4d6d-8aae-22fec400189e","element-6066-11e4-a52e-4f735466cecf":"2d1bd704-40fc-4d6d-8aae-22fec400189e","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"4","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:13:15.466Z","end":"2023-02-17T02:13:30.478Z","_duration":15012,"uid":"57","cid":"0-0","title":"When I enter my name \"Frank\"","fullTitle":"4: When I enter my name \"Frank\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"2d1bd704-40fc-4d6d-8aae-22fec400189e","element-6066-11e4-a52e-4f735466cecf":"2d1bd704-40fc-4d6d-8aae-22fec400189e","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\"input#chat_input\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"b237d21d-befc-42c3-8374-3129320b8303"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"b237d21d-befc-42c3-8374-3129320b8303"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b237d21d-befc-42c3-8374-3129320b8303"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b237d21d-befc-42c3-8374-3129320b8303"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/clear","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/clear","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/value","body":{"text":"Frank"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/value","body":{"text":"Frank"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action7","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action7","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b66ee484-6ad6-4bda-bcff-86f6f9cce983"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b66ee484-6ad6-4bda-bcff-86f6f9cce983","ELEMENT":"b66ee484-6ad6-4bda-bcff-86f6f9cce983"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b66ee484-6ad6-4bda-bcff-86f6f9cce983","ELEMENT":"b66ee484-6ad6-4bda-bcff-86f6f9cce983"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b66ee484-6ad6-4bda-bcff-86f6f9cce983","ELEMENT":"b66ee484-6ad6-4bda-bcff-86f6f9cce983"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b66ee484-6ad6-4bda-bcff-86f6f9cce983","ELEMENT":"b66ee484-6ad6-4bda-bcff-86f6f9cce983"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"b66ee484-6ad6-4bda-bcff-86f6f9cce983"},{"element-6066-11e4-a52e-4f735466cecf":"2fb5ffff-dc6d-448e-bcab-c17405e9358c"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b66ee484-6ad6-4bda-bcff-86f6f9cce983/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b66ee484-6ad6-4bda-bcff-86f6f9cce983/text","body":{},"result":{"value":"Yes"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"63f5f7a2-44be-4303-8cb6-35f9ab444afb"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/63f5f7a2-44be-4303-8cb6-35f9ab444afb/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/63f5f7a2-44be-4303-8cb6-35f9ab444afb/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b66ee484-6ad6-4bda-bcff-86f6f9cce983/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b66ee484-6ad6-4bda-bcff-86f6f9cce983/rect","body":{},"result":{"value":{"height":40,"width":64,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action8","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"b66ee484-6ad6-4bda-bcff-86f6f9cce983"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action8","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"b66ee484-6ad6-4bda-bcff-86f6f9cce983"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b66ee484-6ad6-4bda-bcff-86f6f9cce983/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b66ee484-6ad6-4bda-bcff-86f6f9cce983/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2fb5ffff-dc6d-448e-bcab-c17405e9358c/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"e96448da-9a04-4220-b820-bd82fe345c93"},{"element-6066-11e4-a52e-4f735466cecf":"f95c730f-ca31-4ce0-a2c0-b3113b93ede2"},{"element-6066-11e4-a52e-4f735466cecf":"17c1bfee-f879-423c-a476-efe37468cf09"},{"element-6066-11e4-a52e-4f735466cecf":"235d1360-5373-41fb-9e93-fdf8c5487acf"},{"element-6066-11e4-a52e-4f735466cecf":"98016fec-07d5-4151-9e40-4dcf5a8679d6"},{"element-6066-11e4-a52e-4f735466cecf":"c1a89485-d160-492b-83ed-929d2f1a6b6a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e96448da-9a04-4220-b820-bd82fe345c93"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2fb5ffff-dc6d-448e-bcab-c17405e9358c/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"e96448da-9a04-4220-b820-bd82fe345c93"},{"element-6066-11e4-a52e-4f735466cecf":"f95c730f-ca31-4ce0-a2c0-b3113b93ede2"},{"element-6066-11e4-a52e-4f735466cecf":"17c1bfee-f879-423c-a476-efe37468cf09"},{"element-6066-11e4-a52e-4f735466cecf":"235d1360-5373-41fb-9e93-fdf8c5487acf"},{"element-6066-11e4-a52e-4f735466cecf":"98016fec-07d5-4151-9e40-4dcf5a8679d6"},{"element-6066-11e4-a52e-4f735466cecf":"c1a89485-d160-492b-83ed-929d2f1a6b6a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2fb5ffff-dc6d-448e-bcab-c17405e9358c/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"e96448da-9a04-4220-b820-bd82fe345c93"},{"element-6066-11e4-a52e-4f735466cecf":"f95c730f-ca31-4ce0-a2c0-b3113b93ede2"},{"element-6066-11e4-a52e-4f735466cecf":"17c1bfee-f879-423c-a476-efe37468cf09"},{"element-6066-11e4-a52e-4f735466cecf":"235d1360-5373-41fb-9e93-fdf8c5487acf"},{"element-6066-11e4-a52e-4f735466cecf":"98016fec-07d5-4151-9e40-4dcf5a8679d6"},{"element-6066-11e4-a52e-4f735466cecf":"c1a89485-d160-492b-83ed-929d2f1a6b6a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2fb5ffff-dc6d-448e-bcab-c17405e9358c/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"e96448da-9a04-4220-b820-bd82fe345c93"},{"element-6066-11e4-a52e-4f735466cecf":"f95c730f-ca31-4ce0-a2c0-b3113b93ede2"},{"element-6066-11e4-a52e-4f735466cecf":"17c1bfee-f879-423c-a476-efe37468cf09"},{"element-6066-11e4-a52e-4f735466cecf":"235d1360-5373-41fb-9e93-fdf8c5487acf"},{"element-6066-11e4-a52e-4f735466cecf":"98016fec-07d5-4151-9e40-4dcf5a8679d6"},{"element-6066-11e4-a52e-4f735466cecf":"c1a89485-d160-492b-83ed-929d2f1a6b6a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f95c730f-ca31-4ce0-a2c0-b3113b93ede2/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f95c730f-ca31-4ce0-a2c0-b3113b93ede2/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"4","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:13:30.478Z","end":"2023-02-17T02:13:33.057Z","_duration":2579,"uid":"58","cid":"0-0","title":"Then the chat bot's response contains conversation option Features","fullTitle":"4: Then the chat bot's response contains conversation option Features","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e96448da-9a04-4220-b820-bd82fe345c93"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"e96448da-9a04-4220-b820-bd82fe345c93","ELEMENT":"e96448da-9a04-4220-b820-bd82fe345c93"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"e96448da-9a04-4220-b820-bd82fe345c93","ELEMENT":"e96448da-9a04-4220-b820-bd82fe345c93"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"e96448da-9a04-4220-b820-bd82fe345c93","ELEMENT":"e96448da-9a04-4220-b820-bd82fe345c93"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"e96448da-9a04-4220-b820-bd82fe345c93","ELEMENT":"e96448da-9a04-4220-b820-bd82fe345c93"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"e96448da-9a04-4220-b820-bd82fe345c93"},{"element-6066-11e4-a52e-4f735466cecf":"f95c730f-ca31-4ce0-a2c0-b3113b93ede2"},{"element-6066-11e4-a52e-4f735466cecf":"17c1bfee-f879-423c-a476-efe37468cf09"},{"element-6066-11e4-a52e-4f735466cecf":"235d1360-5373-41fb-9e93-fdf8c5487acf"},{"element-6066-11e4-a52e-4f735466cecf":"98016fec-07d5-4151-9e40-4dcf5a8679d6"},{"element-6066-11e4-a52e-4f735466cecf":"c1a89485-d160-492b-83ed-929d2f1a6b6a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e96448da-9a04-4220-b820-bd82fe345c93/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e96448da-9a04-4220-b820-bd82fe345c93/text","body":{},"result":{"value":"Explain chatbots"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f95c730f-ca31-4ce0-a2c0-b3113b93ede2/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f95c730f-ca31-4ce0-a2c0-b3113b93ede2/text","body":{},"result":{"value":"Make a chatbot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/17c1bfee-f879-423c-a476-efe37468cf09/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/17c1bfee-f879-423c-a476-efe37468cf09/text","body":{},"result":{"value":"Use cases"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/235d1360-5373-41fb-9e93-fdf8c5487acf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/235d1360-5373-41fb-9e93-fdf8c5487acf/text","body":{},"result":{"value":"Features"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/98016fec-07d5-4151-9e40-4dcf5a8679d6/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/98016fec-07d5-4151-9e40-4dcf5a8679d6/text","body":{},"result":{"value":"Contact SnatchBot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c1a89485-d160-492b-83ed-929d2f1a6b6a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c1a89485-d160-492b-83ed-929d2f1a6b6a/text","body":{},"result":{"value":"Costs"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"4","state":"passed","events":[],"errorIndex":0}],"hooks":[{"type":"hook","start":"2023-02-17T02:13:12.411Z","end":"2023-02-17T02:13:12.411Z","_duration":0,"uid":"132","cid":"0-0","title":"","parent":"4","errors":[]},{"type":"hook","start":"2023-02-17T02:13:33.057Z","end":"2023-02-17T02:13:33.057Z","_duration":0,"uid":"137","cid":"0-0","title":"","parent":"4","errors":[]}],"suites":[],"parent":"login.feature:1:1","hooksAndTests":[{"type":"hook","start":"2023-02-17T02:13:12.411Z","end":"2023-02-17T02:13:12.411Z","_duration":0,"uid":"132","cid":"0-0","title":"","parent":"4","errors":[]},{"type":"test","start":"2023-02-17T02:13:12.411Z","end":"2023-02-17T02:13:12.411Z","_duration":0,"uid":"55","cid":"0-0","title":"Given I am on the following url https://snatchbot.me/","fullTitle":"4: Given I am on the following url https://snatchbot.me/","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"4","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:13:12.411Z","end":"2023-02-17T02:13:15.466Z","_duration":3055,"uid":"56","cid":"0-0","title":"And I click on the SnatchBot chat bot","fullTitle":"4: And I click on the SnatchBot chat bot","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3185cb14-5ced-48b0-8c9f-95fa8c5337d4"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3185cb14-5ced-48b0-8c9f-95fa8c5337d4","ELEMENT":"3185cb14-5ced-48b0-8c9f-95fa8c5337d4"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3185cb14-5ced-48b0-8c9f-95fa8c5337d4","ELEMENT":"3185cb14-5ced-48b0-8c9f-95fa8c5337d4"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3185cb14-5ced-48b0-8c9f-95fa8c5337d4","ELEMENT":"3185cb14-5ced-48b0-8c9f-95fa8c5337d4"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3185cb14-5ced-48b0-8c9f-95fa8c5337d4","ELEMENT":"3185cb14-5ced-48b0-8c9f-95fa8c5337d4"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3185cb14-5ced-48b0-8c9f-95fa8c5337d4"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/3185cb14-5ced-48b0-8c9f-95fa8c5337d4/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/3185cb14-5ced-48b0-8c9f-95fa8c5337d4/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2d1bd704-40fc-4d6d-8aae-22fec400189e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"2d1bd704-40fc-4d6d-8aae-22fec400189e","element-6066-11e4-a52e-4f735466cecf":"2d1bd704-40fc-4d6d-8aae-22fec400189e","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"4","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:13:15.466Z","end":"2023-02-17T02:13:30.478Z","_duration":15012,"uid":"57","cid":"0-0","title":"When I enter my name \"Frank\"","fullTitle":"4: When I enter my name \"Frank\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"2d1bd704-40fc-4d6d-8aae-22fec400189e","element-6066-11e4-a52e-4f735466cecf":"2d1bd704-40fc-4d6d-8aae-22fec400189e","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\"input#chat_input\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"b237d21d-befc-42c3-8374-3129320b8303"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"b237d21d-befc-42c3-8374-3129320b8303"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b237d21d-befc-42c3-8374-3129320b8303"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/enabled","body":{},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b237d21d-befc-42c3-8374-3129320b8303"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/clear","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/clear","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/value","body":{"text":"Frank"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b237d21d-befc-42c3-8374-3129320b8303/value","body":{"text":"Frank"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action7","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action7","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b66ee484-6ad6-4bda-bcff-86f6f9cce983"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b66ee484-6ad6-4bda-bcff-86f6f9cce983","ELEMENT":"b66ee484-6ad6-4bda-bcff-86f6f9cce983"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b66ee484-6ad6-4bda-bcff-86f6f9cce983","ELEMENT":"b66ee484-6ad6-4bda-bcff-86f6f9cce983"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b66ee484-6ad6-4bda-bcff-86f6f9cce983","ELEMENT":"b66ee484-6ad6-4bda-bcff-86f6f9cce983"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b66ee484-6ad6-4bda-bcff-86f6f9cce983","ELEMENT":"b66ee484-6ad6-4bda-bcff-86f6f9cce983"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"b66ee484-6ad6-4bda-bcff-86f6f9cce983"},{"element-6066-11e4-a52e-4f735466cecf":"2fb5ffff-dc6d-448e-bcab-c17405e9358c"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b66ee484-6ad6-4bda-bcff-86f6f9cce983/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b66ee484-6ad6-4bda-bcff-86f6f9cce983/text","body":{},"result":{"value":"Yes"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"63f5f7a2-44be-4303-8cb6-35f9ab444afb"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/63f5f7a2-44be-4303-8cb6-35f9ab444afb/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/63f5f7a2-44be-4303-8cb6-35f9ab444afb/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b66ee484-6ad6-4bda-bcff-86f6f9cce983/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b66ee484-6ad6-4bda-bcff-86f6f9cce983/rect","body":{},"result":{"value":{"height":40,"width":64,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action8","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"b66ee484-6ad6-4bda-bcff-86f6f9cce983"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action8","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"b66ee484-6ad6-4bda-bcff-86f6f9cce983"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b66ee484-6ad6-4bda-bcff-86f6f9cce983/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b66ee484-6ad6-4bda-bcff-86f6f9cce983/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2fb5ffff-dc6d-448e-bcab-c17405e9358c/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"e96448da-9a04-4220-b820-bd82fe345c93"},{"element-6066-11e4-a52e-4f735466cecf":"f95c730f-ca31-4ce0-a2c0-b3113b93ede2"},{"element-6066-11e4-a52e-4f735466cecf":"17c1bfee-f879-423c-a476-efe37468cf09"},{"element-6066-11e4-a52e-4f735466cecf":"235d1360-5373-41fb-9e93-fdf8c5487acf"},{"element-6066-11e4-a52e-4f735466cecf":"98016fec-07d5-4151-9e40-4dcf5a8679d6"},{"element-6066-11e4-a52e-4f735466cecf":"c1a89485-d160-492b-83ed-929d2f1a6b6a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e96448da-9a04-4220-b820-bd82fe345c93"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2fb5ffff-dc6d-448e-bcab-c17405e9358c/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"e96448da-9a04-4220-b820-bd82fe345c93"},{"element-6066-11e4-a52e-4f735466cecf":"f95c730f-ca31-4ce0-a2c0-b3113b93ede2"},{"element-6066-11e4-a52e-4f735466cecf":"17c1bfee-f879-423c-a476-efe37468cf09"},{"element-6066-11e4-a52e-4f735466cecf":"235d1360-5373-41fb-9e93-fdf8c5487acf"},{"element-6066-11e4-a52e-4f735466cecf":"98016fec-07d5-4151-9e40-4dcf5a8679d6"},{"element-6066-11e4-a52e-4f735466cecf":"c1a89485-d160-492b-83ed-929d2f1a6b6a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2fb5ffff-dc6d-448e-bcab-c17405e9358c/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"e96448da-9a04-4220-b820-bd82fe345c93"},{"element-6066-11e4-a52e-4f735466cecf":"f95c730f-ca31-4ce0-a2c0-b3113b93ede2"},{"element-6066-11e4-a52e-4f735466cecf":"17c1bfee-f879-423c-a476-efe37468cf09"},{"element-6066-11e4-a52e-4f735466cecf":"235d1360-5373-41fb-9e93-fdf8c5487acf"},{"element-6066-11e4-a52e-4f735466cecf":"98016fec-07d5-4151-9e40-4dcf5a8679d6"},{"element-6066-11e4-a52e-4f735466cecf":"c1a89485-d160-492b-83ed-929d2f1a6b6a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2fb5ffff-dc6d-448e-bcab-c17405e9358c/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"e96448da-9a04-4220-b820-bd82fe345c93"},{"element-6066-11e4-a52e-4f735466cecf":"f95c730f-ca31-4ce0-a2c0-b3113b93ede2"},{"element-6066-11e4-a52e-4f735466cecf":"17c1bfee-f879-423c-a476-efe37468cf09"},{"element-6066-11e4-a52e-4f735466cecf":"235d1360-5373-41fb-9e93-fdf8c5487acf"},{"element-6066-11e4-a52e-4f735466cecf":"98016fec-07d5-4151-9e40-4dcf5a8679d6"},{"element-6066-11e4-a52e-4f735466cecf":"c1a89485-d160-492b-83ed-929d2f1a6b6a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f95c730f-ca31-4ce0-a2c0-b3113b93ede2/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f95c730f-ca31-4ce0-a2c0-b3113b93ede2/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"4","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:13:30.478Z","end":"2023-02-17T02:13:33.057Z","_duration":2579,"uid":"58","cid":"0-0","title":"Then the chat bot's response contains conversation option Features","fullTitle":"4: Then the chat bot's response contains conversation option Features","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e96448da-9a04-4220-b820-bd82fe345c93"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"e96448da-9a04-4220-b820-bd82fe345c93","ELEMENT":"e96448da-9a04-4220-b820-bd82fe345c93"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"e96448da-9a04-4220-b820-bd82fe345c93","ELEMENT":"e96448da-9a04-4220-b820-bd82fe345c93"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"e96448da-9a04-4220-b820-bd82fe345c93","ELEMENT":"e96448da-9a04-4220-b820-bd82fe345c93"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"e96448da-9a04-4220-b820-bd82fe345c93","ELEMENT":"e96448da-9a04-4220-b820-bd82fe345c93"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"e96448da-9a04-4220-b820-bd82fe345c93"},{"element-6066-11e4-a52e-4f735466cecf":"f95c730f-ca31-4ce0-a2c0-b3113b93ede2"},{"element-6066-11e4-a52e-4f735466cecf":"17c1bfee-f879-423c-a476-efe37468cf09"},{"element-6066-11e4-a52e-4f735466cecf":"235d1360-5373-41fb-9e93-fdf8c5487acf"},{"element-6066-11e4-a52e-4f735466cecf":"98016fec-07d5-4151-9e40-4dcf5a8679d6"},{"element-6066-11e4-a52e-4f735466cecf":"c1a89485-d160-492b-83ed-929d2f1a6b6a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e96448da-9a04-4220-b820-bd82fe345c93/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e96448da-9a04-4220-b820-bd82fe345c93/text","body":{},"result":{"value":"Explain chatbots"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f95c730f-ca31-4ce0-a2c0-b3113b93ede2/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f95c730f-ca31-4ce0-a2c0-b3113b93ede2/text","body":{},"result":{"value":"Make a chatbot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/17c1bfee-f879-423c-a476-efe37468cf09/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/17c1bfee-f879-423c-a476-efe37468cf09/text","body":{},"result":{"value":"Use cases"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/235d1360-5373-41fb-9e93-fdf8c5487acf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/235d1360-5373-41fb-9e93-fdf8c5487acf/text","body":{},"result":{"value":"Features"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/98016fec-07d5-4151-9e40-4dcf5a8679d6/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/98016fec-07d5-4151-9e40-4dcf5a8679d6/text","body":{},"result":{"value":"Contact SnatchBot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c1a89485-d160-492b-83ed-929d2f1a6b6a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c1a89485-d160-492b-83ed-929d2f1a6b6a/text","body":{},"result":{"value":"Costs"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"4","state":"passed","events":[],"errorIndex":0},{"type":"hook","start":"2023-02-17T02:13:33.057Z","end":"2023-02-17T02:13:33.057Z","_duration":0,"uid":"137","cid":"0-0","title":"","parent":"4","errors":[]}]},{"type":"scenario","start":"2023-02-17T02:13:33.058Z","end":"2023-02-17T02:13:52.349Z","_duration":19291,"uid":"5","cid":"0-0","file":"/Users/jimwatkins/Workspace/fart/features/login.feature","title":"As a user I want to see the conversation options the chatbot presents me","fullTitle":"login.feature:1:1: As a user I want to see the conversation options the chatbot presents me","tags":[],"tests":[{"type":"test","start":"2023-02-17T02:13:33.058Z","end":"2023-02-17T02:13:33.059Z","_duration":1,"uid":"60","cid":"0-0","title":"Given I am on the following url https://snatchbot.me/","fullTitle":"5: Given I am on the following url https://snatchbot.me/","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"5","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:13:33.059Z","end":"2023-02-17T02:13:35.734Z","_duration":2675,"uid":"61","cid":"0-0","title":"And I click on the SnatchBot chat bot","fullTitle":"5: And I click on the SnatchBot chat bot","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"95555946-e834-4a06-8c3d-30b04dada86e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"95555946-e834-4a06-8c3d-30b04dada86e","ELEMENT":"95555946-e834-4a06-8c3d-30b04dada86e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"95555946-e834-4a06-8c3d-30b04dada86e","ELEMENT":"95555946-e834-4a06-8c3d-30b04dada86e"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"95555946-e834-4a06-8c3d-30b04dada86e","ELEMENT":"95555946-e834-4a06-8c3d-30b04dada86e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"95555946-e834-4a06-8c3d-30b04dada86e","ELEMENT":"95555946-e834-4a06-8c3d-30b04dada86e"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"95555946-e834-4a06-8c3d-30b04dada86e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/95555946-e834-4a06-8c3d-30b04dada86e/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/95555946-e834-4a06-8c3d-30b04dada86e/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0d3ef562-bbf8-425b-ab3d-45825b0e433e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"0d3ef562-bbf8-425b-ab3d-45825b0e433e","element-6066-11e4-a52e-4f735466cecf":"0d3ef562-bbf8-425b-ab3d-45825b0e433e","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"5","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:13:35.735Z","end":"2023-02-17T02:13:49.768Z","_duration":14033,"uid":"62","cid":"0-0","title":"When I enter my name \"Frank\"","fullTitle":"5: When I enter my name \"Frank\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"0d3ef562-bbf8-425b-ab3d-45825b0e433e","element-6066-11e4-a52e-4f735466cecf":"0d3ef562-bbf8-425b-ab3d-45825b0e433e","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\"input#chat_input\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"36a87216-4c28-4577-8b9c-1fe19555dd25"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"36a87216-4c28-4577-8b9c-1fe19555dd25"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"36a87216-4c28-4577-8b9c-1fe19555dd25"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"36a87216-4c28-4577-8b9c-1fe19555dd25"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/clear","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/clear","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/value","body":{"text":"Frank"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/value","body":{"text":"Frank"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action9","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action9","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c55dc04e-e07d-4d81-9b7c-384ffa64e2d2"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"c55dc04e-e07d-4d81-9b7c-384ffa64e2d2","ELEMENT":"c55dc04e-e07d-4d81-9b7c-384ffa64e2d2"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"c55dc04e-e07d-4d81-9b7c-384ffa64e2d2","ELEMENT":"c55dc04e-e07d-4d81-9b7c-384ffa64e2d2"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"c55dc04e-e07d-4d81-9b7c-384ffa64e2d2","ELEMENT":"c55dc04e-e07d-4d81-9b7c-384ffa64e2d2"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"c55dc04e-e07d-4d81-9b7c-384ffa64e2d2","ELEMENT":"c55dc04e-e07d-4d81-9b7c-384ffa64e2d2"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"c55dc04e-e07d-4d81-9b7c-384ffa64e2d2"},{"element-6066-11e4-a52e-4f735466cecf":"a54488a7-6c3a-4abb-9738-4b270aa18683"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c55dc04e-e07d-4d81-9b7c-384ffa64e2d2/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c55dc04e-e07d-4d81-9b7c-384ffa64e2d2/text","body":{},"result":{"value":"Yes"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"eaebc989-61a6-4308-820d-35558077531b"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/eaebc989-61a6-4308-820d-35558077531b/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/eaebc989-61a6-4308-820d-35558077531b/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c55dc04e-e07d-4d81-9b7c-384ffa64e2d2/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c55dc04e-e07d-4d81-9b7c-384ffa64e2d2/rect","body":{},"result":{"value":{"height":40,"width":64,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action10","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"c55dc04e-e07d-4d81-9b7c-384ffa64e2d2"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action10","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"c55dc04e-e07d-4d81-9b7c-384ffa64e2d2"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c55dc04e-e07d-4d81-9b7c-384ffa64e2d2/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c55dc04e-e07d-4d81-9b7c-384ffa64e2d2/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a54488a7-6c3a-4abb-9738-4b270aa18683/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b"},{"element-6066-11e4-a52e-4f735466cecf":"a58e9708-14b9-4e88-957f-a441691d38b4"},{"element-6066-11e4-a52e-4f735466cecf":"0550477b-c909-4c32-bd8f-66afe118fe79"},{"element-6066-11e4-a52e-4f735466cecf":"319bce56-f0ca-43ee-bd98-45f001a713fa"},{"element-6066-11e4-a52e-4f735466cecf":"bc9cb92e-e573-4060-93e9-6fa75395492c"},{"element-6066-11e4-a52e-4f735466cecf":"1ed0d240-b82c-42f2-a51c-f7cd6dccad28"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a54488a7-6c3a-4abb-9738-4b270aa18683/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b"},{"element-6066-11e4-a52e-4f735466cecf":"a58e9708-14b9-4e88-957f-a441691d38b4"},{"element-6066-11e4-a52e-4f735466cecf":"0550477b-c909-4c32-bd8f-66afe118fe79"},{"element-6066-11e4-a52e-4f735466cecf":"319bce56-f0ca-43ee-bd98-45f001a713fa"},{"element-6066-11e4-a52e-4f735466cecf":"bc9cb92e-e573-4060-93e9-6fa75395492c"},{"element-6066-11e4-a52e-4f735466cecf":"1ed0d240-b82c-42f2-a51c-f7cd6dccad28"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a54488a7-6c3a-4abb-9738-4b270aa18683/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b"},{"element-6066-11e4-a52e-4f735466cecf":"a58e9708-14b9-4e88-957f-a441691d38b4"},{"element-6066-11e4-a52e-4f735466cecf":"0550477b-c909-4c32-bd8f-66afe118fe79"},{"element-6066-11e4-a52e-4f735466cecf":"319bce56-f0ca-43ee-bd98-45f001a713fa"},{"element-6066-11e4-a52e-4f735466cecf":"bc9cb92e-e573-4060-93e9-6fa75395492c"},{"element-6066-11e4-a52e-4f735466cecf":"1ed0d240-b82c-42f2-a51c-f7cd6dccad28"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a54488a7-6c3a-4abb-9738-4b270aa18683/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b"},{"element-6066-11e4-a52e-4f735466cecf":"a58e9708-14b9-4e88-957f-a441691d38b4"},{"element-6066-11e4-a52e-4f735466cecf":"0550477b-c909-4c32-bd8f-66afe118fe79"},{"element-6066-11e4-a52e-4f735466cecf":"319bce56-f0ca-43ee-bd98-45f001a713fa"},{"element-6066-11e4-a52e-4f735466cecf":"bc9cb92e-e573-4060-93e9-6fa75395492c"},{"element-6066-11e4-a52e-4f735466cecf":"1ed0d240-b82c-42f2-a51c-f7cd6dccad28"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a58e9708-14b9-4e88-957f-a441691d38b4/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a58e9708-14b9-4e88-957f-a441691d38b4/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"5","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:13:49.769Z","end":"2023-02-17T02:13:52.348Z","_duration":2579,"uid":"63","cid":"0-0","title":"Then the chat bot's response contains conversation option Contact SnatchBot","fullTitle":"5: Then the chat bot's response contains conversation option Contact SnatchBot","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b","ELEMENT":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b","ELEMENT":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b","ELEMENT":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b","ELEMENT":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b"},{"element-6066-11e4-a52e-4f735466cecf":"a58e9708-14b9-4e88-957f-a441691d38b4"},{"element-6066-11e4-a52e-4f735466cecf":"0550477b-c909-4c32-bd8f-66afe118fe79"},{"element-6066-11e4-a52e-4f735466cecf":"319bce56-f0ca-43ee-bd98-45f001a713fa"},{"element-6066-11e4-a52e-4f735466cecf":"bc9cb92e-e573-4060-93e9-6fa75395492c"},{"element-6066-11e4-a52e-4f735466cecf":"1ed0d240-b82c-42f2-a51c-f7cd6dccad28"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1e8b4edf-c062-4527-bd3a-63f7c06bc42b/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1e8b4edf-c062-4527-bd3a-63f7c06bc42b/text","body":{},"result":{"value":"Explain chatbots"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a58e9708-14b9-4e88-957f-a441691d38b4/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a58e9708-14b9-4e88-957f-a441691d38b4/text","body":{},"result":{"value":"Make a chatbot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0550477b-c909-4c32-bd8f-66afe118fe79/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0550477b-c909-4c32-bd8f-66afe118fe79/text","body":{},"result":{"value":"Use cases"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/319bce56-f0ca-43ee-bd98-45f001a713fa/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/319bce56-f0ca-43ee-bd98-45f001a713fa/text","body":{},"result":{"value":"Features"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/bc9cb92e-e573-4060-93e9-6fa75395492c/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/bc9cb92e-e573-4060-93e9-6fa75395492c/text","body":{},"result":{"value":"Contact SnatchBot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1ed0d240-b82c-42f2-a51c-f7cd6dccad28/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1ed0d240-b82c-42f2-a51c-f7cd6dccad28/text","body":{},"result":{"value":"Costs"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"5","state":"passed","events":[],"errorIndex":0}],"hooks":[{"type":"hook","start":"2023-02-17T02:13:33.058Z","end":"2023-02-17T02:13:33.058Z","_duration":0,"uid":"139","cid":"0-0","title":"","parent":"5","errors":[]},{"type":"hook","start":"2023-02-17T02:13:52.349Z","end":"2023-02-17T02:13:52.349Z","_duration":0,"uid":"144","cid":"0-0","title":"","parent":"5","errors":[]}],"suites":[],"parent":"login.feature:1:1","hooksAndTests":[{"type":"hook","start":"2023-02-17T02:13:33.058Z","end":"2023-02-17T02:13:33.058Z","_duration":0,"uid":"139","cid":"0-0","title":"","parent":"5","errors":[]},{"type":"test","start":"2023-02-17T02:13:33.058Z","end":"2023-02-17T02:13:33.059Z","_duration":1,"uid":"60","cid":"0-0","title":"Given I am on the following url https://snatchbot.me/","fullTitle":"5: Given I am on the following url https://snatchbot.me/","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"5","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:13:33.059Z","end":"2023-02-17T02:13:35.734Z","_duration":2675,"uid":"61","cid":"0-0","title":"And I click on the SnatchBot chat bot","fullTitle":"5: And I click on the SnatchBot chat bot","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"95555946-e834-4a06-8c3d-30b04dada86e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"95555946-e834-4a06-8c3d-30b04dada86e","ELEMENT":"95555946-e834-4a06-8c3d-30b04dada86e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"95555946-e834-4a06-8c3d-30b04dada86e","ELEMENT":"95555946-e834-4a06-8c3d-30b04dada86e"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"95555946-e834-4a06-8c3d-30b04dada86e","ELEMENT":"95555946-e834-4a06-8c3d-30b04dada86e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"95555946-e834-4a06-8c3d-30b04dada86e","ELEMENT":"95555946-e834-4a06-8c3d-30b04dada86e"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"95555946-e834-4a06-8c3d-30b04dada86e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/95555946-e834-4a06-8c3d-30b04dada86e/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/95555946-e834-4a06-8c3d-30b04dada86e/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0d3ef562-bbf8-425b-ab3d-45825b0e433e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"0d3ef562-bbf8-425b-ab3d-45825b0e433e","element-6066-11e4-a52e-4f735466cecf":"0d3ef562-bbf8-425b-ab3d-45825b0e433e","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"5","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:13:35.735Z","end":"2023-02-17T02:13:49.768Z","_duration":14033,"uid":"62","cid":"0-0","title":"When I enter my name \"Frank\"","fullTitle":"5: When I enter my name \"Frank\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"0d3ef562-bbf8-425b-ab3d-45825b0e433e","element-6066-11e4-a52e-4f735466cecf":"0d3ef562-bbf8-425b-ab3d-45825b0e433e","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\"input#chat_input\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"36a87216-4c28-4577-8b9c-1fe19555dd25"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"36a87216-4c28-4577-8b9c-1fe19555dd25"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"36a87216-4c28-4577-8b9c-1fe19555dd25"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/enabled","body":{},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"36a87216-4c28-4577-8b9c-1fe19555dd25"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/clear","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/clear","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/value","body":{"text":"Frank"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/36a87216-4c28-4577-8b9c-1fe19555dd25/value","body":{"text":"Frank"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action9","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action9","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c55dc04e-e07d-4d81-9b7c-384ffa64e2d2"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"c55dc04e-e07d-4d81-9b7c-384ffa64e2d2","ELEMENT":"c55dc04e-e07d-4d81-9b7c-384ffa64e2d2"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"c55dc04e-e07d-4d81-9b7c-384ffa64e2d2","ELEMENT":"c55dc04e-e07d-4d81-9b7c-384ffa64e2d2"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"c55dc04e-e07d-4d81-9b7c-384ffa64e2d2","ELEMENT":"c55dc04e-e07d-4d81-9b7c-384ffa64e2d2"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"c55dc04e-e07d-4d81-9b7c-384ffa64e2d2","ELEMENT":"c55dc04e-e07d-4d81-9b7c-384ffa64e2d2"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"c55dc04e-e07d-4d81-9b7c-384ffa64e2d2"},{"element-6066-11e4-a52e-4f735466cecf":"a54488a7-6c3a-4abb-9738-4b270aa18683"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c55dc04e-e07d-4d81-9b7c-384ffa64e2d2/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c55dc04e-e07d-4d81-9b7c-384ffa64e2d2/text","body":{},"result":{"value":"Yes"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"eaebc989-61a6-4308-820d-35558077531b"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/eaebc989-61a6-4308-820d-35558077531b/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/eaebc989-61a6-4308-820d-35558077531b/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c55dc04e-e07d-4d81-9b7c-384ffa64e2d2/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c55dc04e-e07d-4d81-9b7c-384ffa64e2d2/rect","body":{},"result":{"value":{"height":40,"width":64,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action10","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"c55dc04e-e07d-4d81-9b7c-384ffa64e2d2"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action10","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"c55dc04e-e07d-4d81-9b7c-384ffa64e2d2"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c55dc04e-e07d-4d81-9b7c-384ffa64e2d2/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c55dc04e-e07d-4d81-9b7c-384ffa64e2d2/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a54488a7-6c3a-4abb-9738-4b270aa18683/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b"},{"element-6066-11e4-a52e-4f735466cecf":"a58e9708-14b9-4e88-957f-a441691d38b4"},{"element-6066-11e4-a52e-4f735466cecf":"0550477b-c909-4c32-bd8f-66afe118fe79"},{"element-6066-11e4-a52e-4f735466cecf":"319bce56-f0ca-43ee-bd98-45f001a713fa"},{"element-6066-11e4-a52e-4f735466cecf":"bc9cb92e-e573-4060-93e9-6fa75395492c"},{"element-6066-11e4-a52e-4f735466cecf":"1ed0d240-b82c-42f2-a51c-f7cd6dccad28"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a54488a7-6c3a-4abb-9738-4b270aa18683/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b"},{"element-6066-11e4-a52e-4f735466cecf":"a58e9708-14b9-4e88-957f-a441691d38b4"},{"element-6066-11e4-a52e-4f735466cecf":"0550477b-c909-4c32-bd8f-66afe118fe79"},{"element-6066-11e4-a52e-4f735466cecf":"319bce56-f0ca-43ee-bd98-45f001a713fa"},{"element-6066-11e4-a52e-4f735466cecf":"bc9cb92e-e573-4060-93e9-6fa75395492c"},{"element-6066-11e4-a52e-4f735466cecf":"1ed0d240-b82c-42f2-a51c-f7cd6dccad28"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a54488a7-6c3a-4abb-9738-4b270aa18683/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b"},{"element-6066-11e4-a52e-4f735466cecf":"a58e9708-14b9-4e88-957f-a441691d38b4"},{"element-6066-11e4-a52e-4f735466cecf":"0550477b-c909-4c32-bd8f-66afe118fe79"},{"element-6066-11e4-a52e-4f735466cecf":"319bce56-f0ca-43ee-bd98-45f001a713fa"},{"element-6066-11e4-a52e-4f735466cecf":"bc9cb92e-e573-4060-93e9-6fa75395492c"},{"element-6066-11e4-a52e-4f735466cecf":"1ed0d240-b82c-42f2-a51c-f7cd6dccad28"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a54488a7-6c3a-4abb-9738-4b270aa18683/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b"},{"element-6066-11e4-a52e-4f735466cecf":"a58e9708-14b9-4e88-957f-a441691d38b4"},{"element-6066-11e4-a52e-4f735466cecf":"0550477b-c909-4c32-bd8f-66afe118fe79"},{"element-6066-11e4-a52e-4f735466cecf":"319bce56-f0ca-43ee-bd98-45f001a713fa"},{"element-6066-11e4-a52e-4f735466cecf":"bc9cb92e-e573-4060-93e9-6fa75395492c"},{"element-6066-11e4-a52e-4f735466cecf":"1ed0d240-b82c-42f2-a51c-f7cd6dccad28"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a58e9708-14b9-4e88-957f-a441691d38b4/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a58e9708-14b9-4e88-957f-a441691d38b4/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"5","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:13:49.769Z","end":"2023-02-17T02:13:52.348Z","_duration":2579,"uid":"63","cid":"0-0","title":"Then the chat bot's response contains conversation option Contact SnatchBot","fullTitle":"5: Then the chat bot's response contains conversation option Contact SnatchBot","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b","ELEMENT":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b","ELEMENT":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b","ELEMENT":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b","ELEMENT":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"1e8b4edf-c062-4527-bd3a-63f7c06bc42b"},{"element-6066-11e4-a52e-4f735466cecf":"a58e9708-14b9-4e88-957f-a441691d38b4"},{"element-6066-11e4-a52e-4f735466cecf":"0550477b-c909-4c32-bd8f-66afe118fe79"},{"element-6066-11e4-a52e-4f735466cecf":"319bce56-f0ca-43ee-bd98-45f001a713fa"},{"element-6066-11e4-a52e-4f735466cecf":"bc9cb92e-e573-4060-93e9-6fa75395492c"},{"element-6066-11e4-a52e-4f735466cecf":"1ed0d240-b82c-42f2-a51c-f7cd6dccad28"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1e8b4edf-c062-4527-bd3a-63f7c06bc42b/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1e8b4edf-c062-4527-bd3a-63f7c06bc42b/text","body":{},"result":{"value":"Explain chatbots"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a58e9708-14b9-4e88-957f-a441691d38b4/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a58e9708-14b9-4e88-957f-a441691d38b4/text","body":{},"result":{"value":"Make a chatbot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0550477b-c909-4c32-bd8f-66afe118fe79/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0550477b-c909-4c32-bd8f-66afe118fe79/text","body":{},"result":{"value":"Use cases"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/319bce56-f0ca-43ee-bd98-45f001a713fa/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/319bce56-f0ca-43ee-bd98-45f001a713fa/text","body":{},"result":{"value":"Features"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/bc9cb92e-e573-4060-93e9-6fa75395492c/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/bc9cb92e-e573-4060-93e9-6fa75395492c/text","body":{},"result":{"value":"Contact SnatchBot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1ed0d240-b82c-42f2-a51c-f7cd6dccad28/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1ed0d240-b82c-42f2-a51c-f7cd6dccad28/text","body":{},"result":{"value":"Costs"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"5","state":"passed","events":[],"errorIndex":0},{"type":"hook","start":"2023-02-17T02:13:52.349Z","end":"2023-02-17T02:13:52.349Z","_duration":0,"uid":"144","cid":"0-0","title":"","parent":"5","errors":[]}]},{"type":"scenario","start":"2023-02-17T02:13:52.350Z","end":"2023-02-17T02:14:11.578Z","_duration":19227,"uid":"6","cid":"0-0","file":"/Users/jimwatkins/Workspace/fart/features/login.feature","title":"As a user I want to see the conversation options the chatbot presents me","fullTitle":"login.feature:1:1: As a user I want to see the conversation options the chatbot presents me","tags":[],"tests":[{"type":"test","start":"2023-02-17T02:13:52.350Z","end":"2023-02-17T02:13:52.350Z","_duration":0,"uid":"65","cid":"0-0","title":"Given I am on the following url https://snatchbot.me/","fullTitle":"6: Given I am on the following url https://snatchbot.me/","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"6","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:13:52.350Z","end":"2023-02-17T02:13:54.970Z","_duration":2620,"uid":"66","cid":"0-0","title":"And I click on the SnatchBot chat bot","fullTitle":"6: And I click on the SnatchBot chat bot","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cc35810c-7c54-466d-b9eb-6c815371f0d6"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"cc35810c-7c54-466d-b9eb-6c815371f0d6","ELEMENT":"cc35810c-7c54-466d-b9eb-6c815371f0d6"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"cc35810c-7c54-466d-b9eb-6c815371f0d6","ELEMENT":"cc35810c-7c54-466d-b9eb-6c815371f0d6"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"cc35810c-7c54-466d-b9eb-6c815371f0d6","ELEMENT":"cc35810c-7c54-466d-b9eb-6c815371f0d6"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"cc35810c-7c54-466d-b9eb-6c815371f0d6","ELEMENT":"cc35810c-7c54-466d-b9eb-6c815371f0d6"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cc35810c-7c54-466d-b9eb-6c815371f0d6"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cc35810c-7c54-466d-b9eb-6c815371f0d6/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cc35810c-7c54-466d-b9eb-6c815371f0d6/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cb1736c2-c275-4baf-9c73-a98552f75cb9"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"cb1736c2-c275-4baf-9c73-a98552f75cb9","element-6066-11e4-a52e-4f735466cecf":"cb1736c2-c275-4baf-9c73-a98552f75cb9","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"6","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:13:54.971Z","end":"2023-02-17T02:14:08.996Z","_duration":14025,"uid":"67","cid":"0-0","title":"When I enter my name \"Frank\"","fullTitle":"6: When I enter my name \"Frank\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"cb1736c2-c275-4baf-9c73-a98552f75cb9","element-6066-11e4-a52e-4f735466cecf":"cb1736c2-c275-4baf-9c73-a98552f75cb9","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\"input#chat_input\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"92ca7a6b-9ceb-4b71-b093-174da4c9a7c8"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"92ca7a6b-9ceb-4b71-b093-174da4c9a7c8"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"92ca7a6b-9ceb-4b71-b093-174da4c9a7c8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"92ca7a6b-9ceb-4b71-b093-174da4c9a7c8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/clear","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/clear","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/value","body":{"text":"Frank"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/value","body":{"text":"Frank"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action11","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action11","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"28c226a3-5379-4df1-adb5-ffbde799c456"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"28c226a3-5379-4df1-adb5-ffbde799c456","ELEMENT":"28c226a3-5379-4df1-adb5-ffbde799c456"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"28c226a3-5379-4df1-adb5-ffbde799c456","ELEMENT":"28c226a3-5379-4df1-adb5-ffbde799c456"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"28c226a3-5379-4df1-adb5-ffbde799c456","ELEMENT":"28c226a3-5379-4df1-adb5-ffbde799c456"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"28c226a3-5379-4df1-adb5-ffbde799c456","ELEMENT":"28c226a3-5379-4df1-adb5-ffbde799c456"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"28c226a3-5379-4df1-adb5-ffbde799c456"},{"element-6066-11e4-a52e-4f735466cecf":"bfd340ff-58fd-4253-a890-6b788db9128e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/28c226a3-5379-4df1-adb5-ffbde799c456/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/28c226a3-5379-4df1-adb5-ffbde799c456/text","body":{},"result":{"value":"Yes"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9b0278ae-efb9-4864-ab61-f5b62dbfe82b"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9b0278ae-efb9-4864-ab61-f5b62dbfe82b/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9b0278ae-efb9-4864-ab61-f5b62dbfe82b/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/28c226a3-5379-4df1-adb5-ffbde799c456/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/28c226a3-5379-4df1-adb5-ffbde799c456/rect","body":{},"result":{"value":{"height":40,"width":64,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action12","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"28c226a3-5379-4df1-adb5-ffbde799c456"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action12","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"28c226a3-5379-4df1-adb5-ffbde799c456"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/28c226a3-5379-4df1-adb5-ffbde799c456/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/28c226a3-5379-4df1-adb5-ffbde799c456/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/bfd340ff-58fd-4253-a890-6b788db9128e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a18e4d54-4744-4926-afb6-bdece971963d"},{"element-6066-11e4-a52e-4f735466cecf":"c941ddac-b7cd-401b-8f77-2b33d3d6867e"},{"element-6066-11e4-a52e-4f735466cecf":"a8d8334a-2542-4d1e-8bba-a3c653a85737"},{"element-6066-11e4-a52e-4f735466cecf":"8b005a06-124c-4288-9c47-811f4649a5b0"},{"element-6066-11e4-a52e-4f735466cecf":"1fc9671b-97b2-4353-9bb1-ee39fe8e2648"},{"element-6066-11e4-a52e-4f735466cecf":"151bab7b-9dce-4095-9830-8371b50cbb59"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a18e4d54-4744-4926-afb6-bdece971963d"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/bfd340ff-58fd-4253-a890-6b788db9128e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a18e4d54-4744-4926-afb6-bdece971963d"},{"element-6066-11e4-a52e-4f735466cecf":"c941ddac-b7cd-401b-8f77-2b33d3d6867e"},{"element-6066-11e4-a52e-4f735466cecf":"a8d8334a-2542-4d1e-8bba-a3c653a85737"},{"element-6066-11e4-a52e-4f735466cecf":"8b005a06-124c-4288-9c47-811f4649a5b0"},{"element-6066-11e4-a52e-4f735466cecf":"1fc9671b-97b2-4353-9bb1-ee39fe8e2648"},{"element-6066-11e4-a52e-4f735466cecf":"151bab7b-9dce-4095-9830-8371b50cbb59"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/bfd340ff-58fd-4253-a890-6b788db9128e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a18e4d54-4744-4926-afb6-bdece971963d"},{"element-6066-11e4-a52e-4f735466cecf":"c941ddac-b7cd-401b-8f77-2b33d3d6867e"},{"element-6066-11e4-a52e-4f735466cecf":"a8d8334a-2542-4d1e-8bba-a3c653a85737"},{"element-6066-11e4-a52e-4f735466cecf":"8b005a06-124c-4288-9c47-811f4649a5b0"},{"element-6066-11e4-a52e-4f735466cecf":"1fc9671b-97b2-4353-9bb1-ee39fe8e2648"},{"element-6066-11e4-a52e-4f735466cecf":"151bab7b-9dce-4095-9830-8371b50cbb59"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/bfd340ff-58fd-4253-a890-6b788db9128e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a18e4d54-4744-4926-afb6-bdece971963d"},{"element-6066-11e4-a52e-4f735466cecf":"c941ddac-b7cd-401b-8f77-2b33d3d6867e"},{"element-6066-11e4-a52e-4f735466cecf":"a8d8334a-2542-4d1e-8bba-a3c653a85737"},{"element-6066-11e4-a52e-4f735466cecf":"8b005a06-124c-4288-9c47-811f4649a5b0"},{"element-6066-11e4-a52e-4f735466cecf":"1fc9671b-97b2-4353-9bb1-ee39fe8e2648"},{"element-6066-11e4-a52e-4f735466cecf":"151bab7b-9dce-4095-9830-8371b50cbb59"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c941ddac-b7cd-401b-8f77-2b33d3d6867e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c941ddac-b7cd-401b-8f77-2b33d3d6867e/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"6","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:14:08.996Z","end":"2023-02-17T02:14:11.577Z","_duration":2581,"uid":"68","cid":"0-0","title":"Then the chat bot's response contains conversation option Costs","fullTitle":"6: Then the chat bot's response contains conversation option Costs","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a18e4d54-4744-4926-afb6-bdece971963d"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a18e4d54-4744-4926-afb6-bdece971963d","ELEMENT":"a18e4d54-4744-4926-afb6-bdece971963d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a18e4d54-4744-4926-afb6-bdece971963d","ELEMENT":"a18e4d54-4744-4926-afb6-bdece971963d"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a18e4d54-4744-4926-afb6-bdece971963d","ELEMENT":"a18e4d54-4744-4926-afb6-bdece971963d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a18e4d54-4744-4926-afb6-bdece971963d","ELEMENT":"a18e4d54-4744-4926-afb6-bdece971963d"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a18e4d54-4744-4926-afb6-bdece971963d"},{"element-6066-11e4-a52e-4f735466cecf":"c941ddac-b7cd-401b-8f77-2b33d3d6867e"},{"element-6066-11e4-a52e-4f735466cecf":"a8d8334a-2542-4d1e-8bba-a3c653a85737"},{"element-6066-11e4-a52e-4f735466cecf":"8b005a06-124c-4288-9c47-811f4649a5b0"},{"element-6066-11e4-a52e-4f735466cecf":"1fc9671b-97b2-4353-9bb1-ee39fe8e2648"},{"element-6066-11e4-a52e-4f735466cecf":"151bab7b-9dce-4095-9830-8371b50cbb59"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a18e4d54-4744-4926-afb6-bdece971963d/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a18e4d54-4744-4926-afb6-bdece971963d/text","body":{},"result":{"value":"Explain chatbots"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c941ddac-b7cd-401b-8f77-2b33d3d6867e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c941ddac-b7cd-401b-8f77-2b33d3d6867e/text","body":{},"result":{"value":"Make a chatbot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a8d8334a-2542-4d1e-8bba-a3c653a85737/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a8d8334a-2542-4d1e-8bba-a3c653a85737/text","body":{},"result":{"value":"Use cases"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8b005a06-124c-4288-9c47-811f4649a5b0/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8b005a06-124c-4288-9c47-811f4649a5b0/text","body":{},"result":{"value":"Features"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1fc9671b-97b2-4353-9bb1-ee39fe8e2648/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1fc9671b-97b2-4353-9bb1-ee39fe8e2648/text","body":{},"result":{"value":"Contact SnatchBot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/151bab7b-9dce-4095-9830-8371b50cbb59/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/151bab7b-9dce-4095-9830-8371b50cbb59/text","body":{},"result":{"value":"Costs"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"6","state":"passed","events":[],"errorIndex":0}],"hooks":[{"type":"hook","start":"2023-02-17T02:13:52.350Z","end":"2023-02-17T02:13:52.350Z","_duration":0,"uid":"146","cid":"0-0","title":"","parent":"6","errors":[]},{"type":"hook","start":"2023-02-17T02:14:11.577Z","end":"2023-02-17T02:14:11.577Z","_duration":0,"uid":"151","cid":"0-0","title":"","parent":"6","errors":[]}],"suites":[],"parent":"login.feature:1:1","hooksAndTests":[{"type":"hook","start":"2023-02-17T02:13:52.350Z","end":"2023-02-17T02:13:52.350Z","_duration":0,"uid":"146","cid":"0-0","title":"","parent":"6","errors":[]},{"type":"test","start":"2023-02-17T02:13:52.350Z","end":"2023-02-17T02:13:52.350Z","_duration":0,"uid":"65","cid":"0-0","title":"Given I am on the following url https://snatchbot.me/","fullTitle":"6: Given I am on the following url https://snatchbot.me/","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"6","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:13:52.350Z","end":"2023-02-17T02:13:54.970Z","_duration":2620,"uid":"66","cid":"0-0","title":"And I click on the SnatchBot chat bot","fullTitle":"6: And I click on the SnatchBot chat bot","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cc35810c-7c54-466d-b9eb-6c815371f0d6"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"cc35810c-7c54-466d-b9eb-6c815371f0d6","ELEMENT":"cc35810c-7c54-466d-b9eb-6c815371f0d6"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"cc35810c-7c54-466d-b9eb-6c815371f0d6","ELEMENT":"cc35810c-7c54-466d-b9eb-6c815371f0d6"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"cc35810c-7c54-466d-b9eb-6c815371f0d6","ELEMENT":"cc35810c-7c54-466d-b9eb-6c815371f0d6"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"cc35810c-7c54-466d-b9eb-6c815371f0d6","ELEMENT":"cc35810c-7c54-466d-b9eb-6c815371f0d6"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cc35810c-7c54-466d-b9eb-6c815371f0d6"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cc35810c-7c54-466d-b9eb-6c815371f0d6/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cc35810c-7c54-466d-b9eb-6c815371f0d6/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cb1736c2-c275-4baf-9c73-a98552f75cb9"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"cb1736c2-c275-4baf-9c73-a98552f75cb9","element-6066-11e4-a52e-4f735466cecf":"cb1736c2-c275-4baf-9c73-a98552f75cb9","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"6","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:13:54.971Z","end":"2023-02-17T02:14:08.996Z","_duration":14025,"uid":"67","cid":"0-0","title":"When I enter my name \"Frank\"","fullTitle":"6: When I enter my name \"Frank\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"cb1736c2-c275-4baf-9c73-a98552f75cb9","element-6066-11e4-a52e-4f735466cecf":"cb1736c2-c275-4baf-9c73-a98552f75cb9","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\"input#chat_input\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"92ca7a6b-9ceb-4b71-b093-174da4c9a7c8"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"92ca7a6b-9ceb-4b71-b093-174da4c9a7c8"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"92ca7a6b-9ceb-4b71-b093-174da4c9a7c8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/enabled","body":{},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"92ca7a6b-9ceb-4b71-b093-174da4c9a7c8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/clear","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/clear","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/value","body":{"text":"Frank"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/92ca7a6b-9ceb-4b71-b093-174da4c9a7c8/value","body":{"text":"Frank"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action11","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action11","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"28c226a3-5379-4df1-adb5-ffbde799c456"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"28c226a3-5379-4df1-adb5-ffbde799c456","ELEMENT":"28c226a3-5379-4df1-adb5-ffbde799c456"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"28c226a3-5379-4df1-adb5-ffbde799c456","ELEMENT":"28c226a3-5379-4df1-adb5-ffbde799c456"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"28c226a3-5379-4df1-adb5-ffbde799c456","ELEMENT":"28c226a3-5379-4df1-adb5-ffbde799c456"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"28c226a3-5379-4df1-adb5-ffbde799c456","ELEMENT":"28c226a3-5379-4df1-adb5-ffbde799c456"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"28c226a3-5379-4df1-adb5-ffbde799c456"},{"element-6066-11e4-a52e-4f735466cecf":"bfd340ff-58fd-4253-a890-6b788db9128e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/28c226a3-5379-4df1-adb5-ffbde799c456/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/28c226a3-5379-4df1-adb5-ffbde799c456/text","body":{},"result":{"value":"Yes"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9b0278ae-efb9-4864-ab61-f5b62dbfe82b"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9b0278ae-efb9-4864-ab61-f5b62dbfe82b/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9b0278ae-efb9-4864-ab61-f5b62dbfe82b/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/28c226a3-5379-4df1-adb5-ffbde799c456/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/28c226a3-5379-4df1-adb5-ffbde799c456/rect","body":{},"result":{"value":{"height":40,"width":64,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action12","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"28c226a3-5379-4df1-adb5-ffbde799c456"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action12","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"28c226a3-5379-4df1-adb5-ffbde799c456"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/28c226a3-5379-4df1-adb5-ffbde799c456/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/28c226a3-5379-4df1-adb5-ffbde799c456/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/bfd340ff-58fd-4253-a890-6b788db9128e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a18e4d54-4744-4926-afb6-bdece971963d"},{"element-6066-11e4-a52e-4f735466cecf":"c941ddac-b7cd-401b-8f77-2b33d3d6867e"},{"element-6066-11e4-a52e-4f735466cecf":"a8d8334a-2542-4d1e-8bba-a3c653a85737"},{"element-6066-11e4-a52e-4f735466cecf":"8b005a06-124c-4288-9c47-811f4649a5b0"},{"element-6066-11e4-a52e-4f735466cecf":"1fc9671b-97b2-4353-9bb1-ee39fe8e2648"},{"element-6066-11e4-a52e-4f735466cecf":"151bab7b-9dce-4095-9830-8371b50cbb59"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a18e4d54-4744-4926-afb6-bdece971963d"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/bfd340ff-58fd-4253-a890-6b788db9128e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a18e4d54-4744-4926-afb6-bdece971963d"},{"element-6066-11e4-a52e-4f735466cecf":"c941ddac-b7cd-401b-8f77-2b33d3d6867e"},{"element-6066-11e4-a52e-4f735466cecf":"a8d8334a-2542-4d1e-8bba-a3c653a85737"},{"element-6066-11e4-a52e-4f735466cecf":"8b005a06-124c-4288-9c47-811f4649a5b0"},{"element-6066-11e4-a52e-4f735466cecf":"1fc9671b-97b2-4353-9bb1-ee39fe8e2648"},{"element-6066-11e4-a52e-4f735466cecf":"151bab7b-9dce-4095-9830-8371b50cbb59"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/bfd340ff-58fd-4253-a890-6b788db9128e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a18e4d54-4744-4926-afb6-bdece971963d"},{"element-6066-11e4-a52e-4f735466cecf":"c941ddac-b7cd-401b-8f77-2b33d3d6867e"},{"element-6066-11e4-a52e-4f735466cecf":"a8d8334a-2542-4d1e-8bba-a3c653a85737"},{"element-6066-11e4-a52e-4f735466cecf":"8b005a06-124c-4288-9c47-811f4649a5b0"},{"element-6066-11e4-a52e-4f735466cecf":"1fc9671b-97b2-4353-9bb1-ee39fe8e2648"},{"element-6066-11e4-a52e-4f735466cecf":"151bab7b-9dce-4095-9830-8371b50cbb59"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/bfd340ff-58fd-4253-a890-6b788db9128e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a18e4d54-4744-4926-afb6-bdece971963d"},{"element-6066-11e4-a52e-4f735466cecf":"c941ddac-b7cd-401b-8f77-2b33d3d6867e"},{"element-6066-11e4-a52e-4f735466cecf":"a8d8334a-2542-4d1e-8bba-a3c653a85737"},{"element-6066-11e4-a52e-4f735466cecf":"8b005a06-124c-4288-9c47-811f4649a5b0"},{"element-6066-11e4-a52e-4f735466cecf":"1fc9671b-97b2-4353-9bb1-ee39fe8e2648"},{"element-6066-11e4-a52e-4f735466cecf":"151bab7b-9dce-4095-9830-8371b50cbb59"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c941ddac-b7cd-401b-8f77-2b33d3d6867e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c941ddac-b7cd-401b-8f77-2b33d3d6867e/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"6","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:14:08.996Z","end":"2023-02-17T02:14:11.577Z","_duration":2581,"uid":"68","cid":"0-0","title":"Then the chat bot's response contains conversation option Costs","fullTitle":"6: Then the chat bot's response contains conversation option Costs","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a18e4d54-4744-4926-afb6-bdece971963d"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a18e4d54-4744-4926-afb6-bdece971963d","ELEMENT":"a18e4d54-4744-4926-afb6-bdece971963d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a18e4d54-4744-4926-afb6-bdece971963d","ELEMENT":"a18e4d54-4744-4926-afb6-bdece971963d"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a18e4d54-4744-4926-afb6-bdece971963d","ELEMENT":"a18e4d54-4744-4926-afb6-bdece971963d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a18e4d54-4744-4926-afb6-bdece971963d","ELEMENT":"a18e4d54-4744-4926-afb6-bdece971963d"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a18e4d54-4744-4926-afb6-bdece971963d"},{"element-6066-11e4-a52e-4f735466cecf":"c941ddac-b7cd-401b-8f77-2b33d3d6867e"},{"element-6066-11e4-a52e-4f735466cecf":"a8d8334a-2542-4d1e-8bba-a3c653a85737"},{"element-6066-11e4-a52e-4f735466cecf":"8b005a06-124c-4288-9c47-811f4649a5b0"},{"element-6066-11e4-a52e-4f735466cecf":"1fc9671b-97b2-4353-9bb1-ee39fe8e2648"},{"element-6066-11e4-a52e-4f735466cecf":"151bab7b-9dce-4095-9830-8371b50cbb59"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a18e4d54-4744-4926-afb6-bdece971963d/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a18e4d54-4744-4926-afb6-bdece971963d/text","body":{},"result":{"value":"Explain chatbots"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c941ddac-b7cd-401b-8f77-2b33d3d6867e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c941ddac-b7cd-401b-8f77-2b33d3d6867e/text","body":{},"result":{"value":"Make a chatbot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a8d8334a-2542-4d1e-8bba-a3c653a85737/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a8d8334a-2542-4d1e-8bba-a3c653a85737/text","body":{},"result":{"value":"Use cases"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8b005a06-124c-4288-9c47-811f4649a5b0/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8b005a06-124c-4288-9c47-811f4649a5b0/text","body":{},"result":{"value":"Features"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1fc9671b-97b2-4353-9bb1-ee39fe8e2648/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1fc9671b-97b2-4353-9bb1-ee39fe8e2648/text","body":{},"result":{"value":"Contact SnatchBot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/151bab7b-9dce-4095-9830-8371b50cbb59/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/151bab7b-9dce-4095-9830-8371b50cbb59/text","body":{},"result":{"value":"Costs"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"6","state":"passed","events":[],"errorIndex":0},{"type":"hook","start":"2023-02-17T02:14:11.577Z","end":"2023-02-17T02:14:11.577Z","_duration":0,"uid":"151","cid":"0-0","title":"","parent":"6","errors":[]}]},{"type":"scenario","start":"2023-02-17T02:14:11.578Z","end":"2023-02-17T02:14:44.391Z","_duration":32811,"uid":"7","cid":"0-0","file":"/Users/jimwatkins/Workspace/fart/features/login.feature","title":"As a user I want to be able to learn about costs to create a few chatbots","fullTitle":"login.feature:1:1: As a user I want to be able to learn about costs to create a few chatbots","tags":[],"tests":[{"type":"test","start":"2023-02-17T02:14:11.579Z","end":"2023-02-17T02:14:11.579Z","_duration":0,"uid":"70","cid":"0-0","title":"Given I am on the following url https://snatchbot.me/","fullTitle":"7: Given I am on the following url https://snatchbot.me/","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"7","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:14:11.579Z","end":"2023-02-17T02:14:14.311Z","_duration":2732,"uid":"71","cid":"0-0","title":"And I click on the SnatchBot chat bot","fullTitle":"7: And I click on the SnatchBot chat bot","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4259168a-4a75-4a8e-bff2-0231cf0bc81d"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"4259168a-4a75-4a8e-bff2-0231cf0bc81d","ELEMENT":"4259168a-4a75-4a8e-bff2-0231cf0bc81d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"4259168a-4a75-4a8e-bff2-0231cf0bc81d","ELEMENT":"4259168a-4a75-4a8e-bff2-0231cf0bc81d"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"4259168a-4a75-4a8e-bff2-0231cf0bc81d","ELEMENT":"4259168a-4a75-4a8e-bff2-0231cf0bc81d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"4259168a-4a75-4a8e-bff2-0231cf0bc81d","ELEMENT":"4259168a-4a75-4a8e-bff2-0231cf0bc81d"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4259168a-4a75-4a8e-bff2-0231cf0bc81d"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4259168a-4a75-4a8e-bff2-0231cf0bc81d/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4259168a-4a75-4a8e-bff2-0231cf0bc81d/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3f575569-8c35-4a33-9d5c-d18cf0dd470d"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"3f575569-8c35-4a33-9d5c-d18cf0dd470d","element-6066-11e4-a52e-4f735466cecf":"3f575569-8c35-4a33-9d5c-d18cf0dd470d","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"7","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:14:14.311Z","end":"2023-02-17T02:14:28.318Z","_duration":14007,"uid":"72","cid":"0-0","title":"And I enter my name \"John\"","fullTitle":"7: And I enter my name \"John\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"3f575569-8c35-4a33-9d5c-d18cf0dd470d","element-6066-11e4-a52e-4f735466cecf":"3f575569-8c35-4a33-9d5c-d18cf0dd470d","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\"input#chat_input\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"19701f27-026a-437c-be1d-1f58ed21bcbe"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"19701f27-026a-437c-be1d-1f58ed21bcbe"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"19701f27-026a-437c-be1d-1f58ed21bcbe"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"19701f27-026a-437c-be1d-1f58ed21bcbe"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/clear","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/clear","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/value","body":{"text":"John"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/value","body":{"text":"John"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action13","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action13","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0","ELEMENT":"8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0","ELEMENT":"8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0","ELEMENT":"8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0","ELEMENT":"8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0"},{"element-6066-11e4-a52e-4f735466cecf":"6f008a34-649c-4b53-aeb1-8103da69eaa9"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0/text","body":{},"result":{"value":"Yes"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ab113913-f11a-49b2-a7dc-59e6cad3c9e9"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ab113913-f11a-49b2-a7dc-59e6cad3c9e9/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ab113913-f11a-49b2-a7dc-59e6cad3c9e9/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0/rect","body":{},"result":{"value":{"height":40,"width":64,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action14","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action14","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6f008a34-649c-4b53-aeb1-8103da69eaa9/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"00b963a9-4c3c-43f7-8837-248d3958c0c4"},{"element-6066-11e4-a52e-4f735466cecf":"e19bfa53-909f-41ae-affe-70889a9b4aa0"},{"element-6066-11e4-a52e-4f735466cecf":"c8e57a57-9908-43c0-bfa5-14341ba21288"},{"element-6066-11e4-a52e-4f735466cecf":"250f4746-1eb2-4fbf-b450-8ce6e0645a00"},{"element-6066-11e4-a52e-4f735466cecf":"72a58c15-6939-4172-9e72-724719785a10"},{"element-6066-11e4-a52e-4f735466cecf":"ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"00b963a9-4c3c-43f7-8837-248d3958c0c4"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6f008a34-649c-4b53-aeb1-8103da69eaa9/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"00b963a9-4c3c-43f7-8837-248d3958c0c4"},{"element-6066-11e4-a52e-4f735466cecf":"e19bfa53-909f-41ae-affe-70889a9b4aa0"},{"element-6066-11e4-a52e-4f735466cecf":"c8e57a57-9908-43c0-bfa5-14341ba21288"},{"element-6066-11e4-a52e-4f735466cecf":"250f4746-1eb2-4fbf-b450-8ce6e0645a00"},{"element-6066-11e4-a52e-4f735466cecf":"72a58c15-6939-4172-9e72-724719785a10"},{"element-6066-11e4-a52e-4f735466cecf":"ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6f008a34-649c-4b53-aeb1-8103da69eaa9/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"00b963a9-4c3c-43f7-8837-248d3958c0c4"},{"element-6066-11e4-a52e-4f735466cecf":"e19bfa53-909f-41ae-affe-70889a9b4aa0"},{"element-6066-11e4-a52e-4f735466cecf":"c8e57a57-9908-43c0-bfa5-14341ba21288"},{"element-6066-11e4-a52e-4f735466cecf":"250f4746-1eb2-4fbf-b450-8ce6e0645a00"},{"element-6066-11e4-a52e-4f735466cecf":"72a58c15-6939-4172-9e72-724719785a10"},{"element-6066-11e4-a52e-4f735466cecf":"ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6f008a34-649c-4b53-aeb1-8103da69eaa9/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"00b963a9-4c3c-43f7-8837-248d3958c0c4"},{"element-6066-11e4-a52e-4f735466cecf":"e19bfa53-909f-41ae-affe-70889a9b4aa0"},{"element-6066-11e4-a52e-4f735466cecf":"c8e57a57-9908-43c0-bfa5-14341ba21288"},{"element-6066-11e4-a52e-4f735466cecf":"250f4746-1eb2-4fbf-b450-8ce6e0645a00"},{"element-6066-11e4-a52e-4f735466cecf":"72a58c15-6939-4172-9e72-724719785a10"},{"element-6066-11e4-a52e-4f735466cecf":"ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e19bfa53-909f-41ae-affe-70889a9b4aa0/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e19bfa53-909f-41ae-affe-70889a9b4aa0/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"7","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:14:28.319Z","end":"2023-02-17T02:14:30.650Z","_duration":2331,"uid":"73","cid":"0-0","title":"When I choose chat option \"Costs\"","fullTitle":"7: When I choose chat option \"Costs\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"00b963a9-4c3c-43f7-8837-248d3958c0c4"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"00b963a9-4c3c-43f7-8837-248d3958c0c4","ELEMENT":"00b963a9-4c3c-43f7-8837-248d3958c0c4"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"00b963a9-4c3c-43f7-8837-248d3958c0c4","ELEMENT":"00b963a9-4c3c-43f7-8837-248d3958c0c4"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"00b963a9-4c3c-43f7-8837-248d3958c0c4","ELEMENT":"00b963a9-4c3c-43f7-8837-248d3958c0c4"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"00b963a9-4c3c-43f7-8837-248d3958c0c4","ELEMENT":"00b963a9-4c3c-43f7-8837-248d3958c0c4"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"00b963a9-4c3c-43f7-8837-248d3958c0c4"},{"element-6066-11e4-a52e-4f735466cecf":"e19bfa53-909f-41ae-affe-70889a9b4aa0"},{"element-6066-11e4-a52e-4f735466cecf":"c8e57a57-9908-43c0-bfa5-14341ba21288"},{"element-6066-11e4-a52e-4f735466cecf":"250f4746-1eb2-4fbf-b450-8ce6e0645a00"},{"element-6066-11e4-a52e-4f735466cecf":"72a58c15-6939-4172-9e72-724719785a10"},{"element-6066-11e4-a52e-4f735466cecf":"ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/00b963a9-4c3c-43f7-8837-248d3958c0c4/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/00b963a9-4c3c-43f7-8837-248d3958c0c4/text","body":{},"result":{"value":"Explain chatbots"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e19bfa53-909f-41ae-affe-70889a9b4aa0/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e19bfa53-909f-41ae-affe-70889a9b4aa0/text","body":{},"result":{"value":"Make a chatbot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c8e57a57-9908-43c0-bfa5-14341ba21288/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c8e57a57-9908-43c0-bfa5-14341ba21288/text","body":{},"result":{"value":"Use cases"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/250f4746-1eb2-4fbf-b450-8ce6e0645a00/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/250f4746-1eb2-4fbf-b450-8ce6e0645a00/text","body":{},"result":{"value":"Features"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/72a58c15-6939-4172-9e72-724719785a10/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/72a58c15-6939-4172-9e72-724719785a10/text","body":{},"result":{"value":"Contact SnatchBot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50/text","body":{},"result":{"value":"Costs"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ab113913-f11a-49b2-a7dc-59e6cad3c9e9"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ab113913-f11a-49b2-a7dc-59e6cad3c9e9/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ab113913-f11a-49b2-a7dc-59e6cad3c9e9/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50/rect","body":{},"result":{"value":{"height":40,"width":68,"x":229.625,"y":448.1953125}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action15","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action15","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"7","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:14:30.650Z","end":"2023-02-17T02:14:35.610Z","_duration":4960,"uid":"74","cid":"0-0","title":"And I choose chat option \"A few\"","fullTitle":"7: And I choose chat option \"A few\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"da71a60d-b0d8-4af0-81dd-c3d417f76e53"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"da71a60d-b0d8-4af0-81dd-c3d417f76e53","ELEMENT":"da71a60d-b0d8-4af0-81dd-c3d417f76e53"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"da71a60d-b0d8-4af0-81dd-c3d417f76e53","ELEMENT":"da71a60d-b0d8-4af0-81dd-c3d417f76e53"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"da71a60d-b0d8-4af0-81dd-c3d417f76e53","ELEMENT":"da71a60d-b0d8-4af0-81dd-c3d417f76e53"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"da71a60d-b0d8-4af0-81dd-c3d417f76e53","ELEMENT":"da71a60d-b0d8-4af0-81dd-c3d417f76e53"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"da71a60d-b0d8-4af0-81dd-c3d417f76e53"},{"element-6066-11e4-a52e-4f735466cecf":"2062722d-7f76-4e6b-97af-3c4f941fee4a"},{"element-6066-11e4-a52e-4f735466cecf":"d83a9b75-3c17-4a17-b448-5e35e2f0e392"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/da71a60d-b0d8-4af0-81dd-c3d417f76e53/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/da71a60d-b0d8-4af0-81dd-c3d417f76e53/text","body":{},"result":{"value":"A few"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ab113913-f11a-49b2-a7dc-59e6cad3c9e9"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ab113913-f11a-49b2-a7dc-59e6cad3c9e9/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ab113913-f11a-49b2-a7dc-59e6cad3c9e9/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/da71a60d-b0d8-4af0-81dd-c3d417f76e53/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/da71a60d-b0d8-4af0-81dd-c3d417f76e53/rect","body":{},"result":{"value":{"height":40,"width":68,"x":70,"y":479}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action16","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"da71a60d-b0d8-4af0-81dd-c3d417f76e53"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action16","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"da71a60d-b0d8-4af0-81dd-c3d417f76e53"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/da71a60d-b0d8-4af0-81dd-c3d417f76e53/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/da71a60d-b0d8-4af0-81dd-c3d417f76e53/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2062722d-7f76-4e6b-97af-3c4f941fee4a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2062722d-7f76-4e6b-97af-3c4f941fee4a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2062722d-7f76-4e6b-97af-3c4f941fee4a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2062722d-7f76-4e6b-97af-3c4f941fee4a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9a64f9c7-c0f9-45be-909c-eb33782a943d/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9a64f9c7-c0f9-45be-909c-eb33782a943d/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d83a9b75-3c17-4a17-b448-5e35e2f0e392/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d83a9b75-3c17-4a17-b448-5e35e2f0e392/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d83a9b75-3c17-4a17-b448-5e35e2f0e392/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d83a9b75-3c17-4a17-b448-5e35e2f0e392/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d83a9b75-3c17-4a17-b448-5e35e2f0e392/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d83a9b75-3c17-4a17-b448-5e35e2f0e392/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d83a9b75-3c17-4a17-b448-5e35e2f0e392/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d83a9b75-3c17-4a17-b448-5e35e2f0e392/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/fc4deb51-3bf3-468d-8103-bf2d858a34e8/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/fc4deb51-3bf3-468d-8103-bf2d858a34e8/text","body":{},"result":{"value":"Approximately?"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"7","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:14:35.610Z","end":"2023-02-17T02:14:39.979Z","_duration":4369,"uid":"75","cid":"0-0","title":"And I choose chat option \"Approximately?\"","fullTitle":"7: And I choose chat option \"Approximately?\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8","ELEMENT":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8","ELEMENT":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8","ELEMENT":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8","ELEMENT":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/fc4deb51-3bf3-468d-8103-bf2d858a34e8/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/fc4deb51-3bf3-468d-8103-bf2d858a34e8/text","body":{},"result":{"value":"Approximately?"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ab113913-f11a-49b2-a7dc-59e6cad3c9e9"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ab113913-f11a-49b2-a7dc-59e6cad3c9e9/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ab113913-f11a-49b2-a7dc-59e6cad3c9e9/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/fc4deb51-3bf3-468d-8103-bf2d858a34e8/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/fc4deb51-3bf3-468d-8103-bf2d858a34e8/rect","body":{},"result":{"value":{"height":40,"width":129,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action17","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action17","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fc4deb51-3bf3-468d-8103-bf2d858a34e8/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fc4deb51-3bf3-468d-8103-bf2d858a34e8/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9a64f9c7-c0f9-45be-909c-eb33782a943d/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c"},{"element-6066-11e4-a52e-4f735466cecf":"a18594e7-568c-4884-a1a9-f8d1a687e2db"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9a64f9c7-c0f9-45be-909c-eb33782a943d/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c"},{"element-6066-11e4-a52e-4f735466cecf":"a18594e7-568c-4884-a1a9-f8d1a687e2db"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9a64f9c7-c0f9-45be-909c-eb33782a943d/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c"},{"element-6066-11e4-a52e-4f735466cecf":"a18594e7-568c-4884-a1a9-f8d1a687e2db"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9a64f9c7-c0f9-45be-909c-eb33782a943d/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c"},{"element-6066-11e4-a52e-4f735466cecf":"a18594e7-568c-4884-a1a9-f8d1a687e2db"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a18594e7-568c-4884-a1a9-f8d1a687e2db/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a18594e7-568c-4884-a1a9-f8d1a687e2db/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"7","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:14:39.979Z","end":"2023-02-17T02:14:44.389Z","_duration":4410,"uid":"76","cid":"0-0","title":"Then the approximate cost is \"$3,000\" with recurring fees of \"$30\" per month","fullTitle":"7: Then the approximate cost is \"$3,000\" with recurring fees of \"$30\" per month","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c","ELEMENT":"25059019-755e-49f1-a89c-28b80253863c"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c","ELEMENT":"25059019-755e-49f1-a89c-28b80253863c"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c","ELEMENT":"25059019-755e-49f1-a89c-28b80253863c"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c","ELEMENT":"25059019-755e-49f1-a89c-28b80253863c"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__body"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__body"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"705f099e-8597-4511-9302-9dc51b2f92fd"},{"element-6066-11e4-a52e-4f735466cecf":"49a4319d-8427-4ef6-9e3b-7a8dec0b3c53"},{"element-6066-11e4-a52e-4f735466cecf":"b846cdd1-5ab2-49a7-92af-ec9581b50e48"},{"element-6066-11e4-a52e-4f735466cecf":"81227cfb-fe08-4729-8dd1-f36982fb9b59"},{"element-6066-11e4-a52e-4f735466cecf":"e8380e9c-2f96-4ab7-8f4e-8daa97102da7"},{"element-6066-11e4-a52e-4f735466cecf":"7c452e51-8df0-493a-a873-cde53f80af10"},{"element-6066-11e4-a52e-4f735466cecf":"5f1e4037-98c7-40a3-ade3-6252b382b8a0"},{"element-6066-11e4-a52e-4f735466cecf":"e95a66d0-1666-4e4d-aa0f-35c90f453ed6"},{"element-6066-11e4-a52e-4f735466cecf":"b897460d-4d94-4344-89e3-c180bf7ea2c1"},{"element-6066-11e4-a52e-4f735466cecf":"959ac24f-4b81-4f47-a4fb-fb9c4025a3e7"},{"element-6066-11e4-a52e-4f735466cecf":"df526cfc-faa5-4e82-b721-0946b8fb3a86"},{"element-6066-11e4-a52e-4f735466cecf":"f93f096d-2822-49de-95ee-de26d2cf721f"},{"element-6066-11e4-a52e-4f735466cecf":"b468608b-94d9-4967-8d30-2a791c750852"},{"element-6066-11e4-a52e-4f735466cecf":"80cbfcb8-d350-4f7a-9861-0b1134ddfad1"},{"element-6066-11e4-a52e-4f735466cecf":"d68a9b9d-b1d7-4e9a-9d4c-8fd4044794f3"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d68a9b9d-b1d7-4e9a-9d4c-8fd4044794f3/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d68a9b9d-b1d7-4e9a-9d4c-8fd4044794f3/text","body":{},"result":{"value":"The good news is we are highly competitive and, typically, our chatbot builds cost around $3,000."},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c","ELEMENT":"25059019-755e-49f1-a89c-28b80253863c"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c","ELEMENT":"25059019-755e-49f1-a89c-28b80253863c"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c","ELEMENT":"25059019-755e-49f1-a89c-28b80253863c"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c","ELEMENT":"25059019-755e-49f1-a89c-28b80253863c"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c"},{"element-6066-11e4-a52e-4f735466cecf":"a18594e7-568c-4884-a1a9-f8d1a687e2db"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/25059019-755e-49f1-a89c-28b80253863c/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/25059019-755e-49f1-a89c-28b80253863c/text","body":{},"result":{"value":"Recurring fees?"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ab113913-f11a-49b2-a7dc-59e6cad3c9e9"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ab113913-f11a-49b2-a7dc-59e6cad3c9e9/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ab113913-f11a-49b2-a7dc-59e6cad3c9e9/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/25059019-755e-49f1-a89c-28b80253863c/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/25059019-755e-49f1-a89c-28b80253863c/rect","body":{},"result":{"value":{"height":40,"width":130,"x":70,"y":479}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action18","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action18","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/25059019-755e-49f1-a89c-28b80253863c/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/25059019-755e-49f1-a89c-28b80253863c/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a18594e7-568c-4884-a1a9-f8d1a687e2db/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"51a6a8ee-1541-4401-bb7b-71931ca663c9"},{"element-6066-11e4-a52e-4f735466cecf":"8dc3beca-09f5-4609-a994-bdab238c19c5"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"51a6a8ee-1541-4401-bb7b-71931ca663c9"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a18594e7-568c-4884-a1a9-f8d1a687e2db/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"51a6a8ee-1541-4401-bb7b-71931ca663c9"},{"element-6066-11e4-a52e-4f735466cecf":"8dc3beca-09f5-4609-a994-bdab238c19c5"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a18594e7-568c-4884-a1a9-f8d1a687e2db/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"51a6a8ee-1541-4401-bb7b-71931ca663c9"},{"element-6066-11e4-a52e-4f735466cecf":"8dc3beca-09f5-4609-a994-bdab238c19c5"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a18594e7-568c-4884-a1a9-f8d1a687e2db/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"51a6a8ee-1541-4401-bb7b-71931ca663c9"},{"element-6066-11e4-a52e-4f735466cecf":"8dc3beca-09f5-4609-a994-bdab238c19c5"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8dc3beca-09f5-4609-a994-bdab238c19c5/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8dc3beca-09f5-4609-a994-bdab238c19c5/text","body":{},"result":{"value":"Done"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"51a6a8ee-1541-4401-bb7b-71931ca663c9"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"51a6a8ee-1541-4401-bb7b-71931ca663c9","ELEMENT":"51a6a8ee-1541-4401-bb7b-71931ca663c9"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"51a6a8ee-1541-4401-bb7b-71931ca663c9","ELEMENT":"51a6a8ee-1541-4401-bb7b-71931ca663c9"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"51a6a8ee-1541-4401-bb7b-71931ca663c9","ELEMENT":"51a6a8ee-1541-4401-bb7b-71931ca663c9"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"51a6a8ee-1541-4401-bb7b-71931ca663c9","ELEMENT":"51a6a8ee-1541-4401-bb7b-71931ca663c9"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__body"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__body"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"705f099e-8597-4511-9302-9dc51b2f92fd"},{"element-6066-11e4-a52e-4f735466cecf":"49a4319d-8427-4ef6-9e3b-7a8dec0b3c53"},{"element-6066-11e4-a52e-4f735466cecf":"b846cdd1-5ab2-49a7-92af-ec9581b50e48"},{"element-6066-11e4-a52e-4f735466cecf":"81227cfb-fe08-4729-8dd1-f36982fb9b59"},{"element-6066-11e4-a52e-4f735466cecf":"e8380e9c-2f96-4ab7-8f4e-8daa97102da7"},{"element-6066-11e4-a52e-4f735466cecf":"7c452e51-8df0-493a-a873-cde53f80af10"},{"element-6066-11e4-a52e-4f735466cecf":"5f1e4037-98c7-40a3-ade3-6252b382b8a0"},{"element-6066-11e4-a52e-4f735466cecf":"e95a66d0-1666-4e4d-aa0f-35c90f453ed6"},{"element-6066-11e4-a52e-4f735466cecf":"b897460d-4d94-4344-89e3-c180bf7ea2c1"},{"element-6066-11e4-a52e-4f735466cecf":"959ac24f-4b81-4f47-a4fb-fb9c4025a3e7"},{"element-6066-11e4-a52e-4f735466cecf":"df526cfc-faa5-4e82-b721-0946b8fb3a86"},{"element-6066-11e4-a52e-4f735466cecf":"f93f096d-2822-49de-95ee-de26d2cf721f"},{"element-6066-11e4-a52e-4f735466cecf":"b468608b-94d9-4967-8d30-2a791c750852"},{"element-6066-11e4-a52e-4f735466cecf":"80cbfcb8-d350-4f7a-9861-0b1134ddfad1"},{"element-6066-11e4-a52e-4f735466cecf":"d68a9b9d-b1d7-4e9a-9d4c-8fd4044794f3"},{"element-6066-11e4-a52e-4f735466cecf":"676f2cce-e01c-4e47-8538-dab3b9a77964"},{"element-6066-11e4-a52e-4f735466cecf":"bcf33012-98a2-410d-bb78-b526da2b0422"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/bcf33012-98a2-410d-bb78-b526da2b0422/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/bcf33012-98a2-410d-bb78-b526da2b0422/text","body":{},"result":{"value":"Yes, there is a recurring monthly cost, which is our Pro-plan. The Pro-plan costs start at $30 a month."},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"7","state":"passed","events":[],"errorIndex":0}],"hooks":[{"type":"hook","start":"2023-02-17T02:14:11.578Z","end":"2023-02-17T02:14:11.579Z","_duration":1,"uid":"153","cid":"0-0","title":"","parent":"7","errors":[]},{"type":"hook","start":"2023-02-17T02:14:44.389Z","end":"2023-02-17T02:14:44.389Z","_duration":0,"uid":"161","cid":"0-0","title":"","parent":"7","errors":[]}],"suites":[],"parent":"login.feature:1:1","hooksAndTests":[{"type":"hook","start":"2023-02-17T02:14:11.578Z","end":"2023-02-17T02:14:11.579Z","_duration":1,"uid":"153","cid":"0-0","title":"","parent":"7","errors":[]},{"type":"test","start":"2023-02-17T02:14:11.579Z","end":"2023-02-17T02:14:11.579Z","_duration":0,"uid":"70","cid":"0-0","title":"Given I am on the following url https://snatchbot.me/","fullTitle":"7: Given I am on the following url https://snatchbot.me/","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"7","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:14:11.579Z","end":"2023-02-17T02:14:14.311Z","_duration":2732,"uid":"71","cid":"0-0","title":"And I click on the SnatchBot chat bot","fullTitle":"7: And I click on the SnatchBot chat bot","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4259168a-4a75-4a8e-bff2-0231cf0bc81d"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"4259168a-4a75-4a8e-bff2-0231cf0bc81d","ELEMENT":"4259168a-4a75-4a8e-bff2-0231cf0bc81d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"4259168a-4a75-4a8e-bff2-0231cf0bc81d","ELEMENT":"4259168a-4a75-4a8e-bff2-0231cf0bc81d"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"4259168a-4a75-4a8e-bff2-0231cf0bc81d","ELEMENT":"4259168a-4a75-4a8e-bff2-0231cf0bc81d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"4259168a-4a75-4a8e-bff2-0231cf0bc81d","ELEMENT":"4259168a-4a75-4a8e-bff2-0231cf0bc81d"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4259168a-4a75-4a8e-bff2-0231cf0bc81d"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4259168a-4a75-4a8e-bff2-0231cf0bc81d/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4259168a-4a75-4a8e-bff2-0231cf0bc81d/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3f575569-8c35-4a33-9d5c-d18cf0dd470d"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"3f575569-8c35-4a33-9d5c-d18cf0dd470d","element-6066-11e4-a52e-4f735466cecf":"3f575569-8c35-4a33-9d5c-d18cf0dd470d","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"7","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:14:14.311Z","end":"2023-02-17T02:14:28.318Z","_duration":14007,"uid":"72","cid":"0-0","title":"And I enter my name \"John\"","fullTitle":"7: And I enter my name \"John\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"3f575569-8c35-4a33-9d5c-d18cf0dd470d","element-6066-11e4-a52e-4f735466cecf":"3f575569-8c35-4a33-9d5c-d18cf0dd470d","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\"input#chat_input\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"19701f27-026a-437c-be1d-1f58ed21bcbe"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"19701f27-026a-437c-be1d-1f58ed21bcbe"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"19701f27-026a-437c-be1d-1f58ed21bcbe"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/enabled","body":{},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"19701f27-026a-437c-be1d-1f58ed21bcbe"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/clear","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/clear","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/value","body":{"text":"John"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/19701f27-026a-437c-be1d-1f58ed21bcbe/value","body":{"text":"John"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action13","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action13","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0","ELEMENT":"8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0","ELEMENT":"8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0","ELEMENT":"8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0","ELEMENT":"8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0"},{"element-6066-11e4-a52e-4f735466cecf":"6f008a34-649c-4b53-aeb1-8103da69eaa9"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0/text","body":{},"result":{"value":"Yes"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ab113913-f11a-49b2-a7dc-59e6cad3c9e9"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ab113913-f11a-49b2-a7dc-59e6cad3c9e9/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ab113913-f11a-49b2-a7dc-59e6cad3c9e9/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0/rect","body":{},"result":{"value":{"height":40,"width":64,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action14","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action14","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8a9a1975-4c4b-4792-abb1-ed3d8c5c9ea0/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6f008a34-649c-4b53-aeb1-8103da69eaa9/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"00b963a9-4c3c-43f7-8837-248d3958c0c4"},{"element-6066-11e4-a52e-4f735466cecf":"e19bfa53-909f-41ae-affe-70889a9b4aa0"},{"element-6066-11e4-a52e-4f735466cecf":"c8e57a57-9908-43c0-bfa5-14341ba21288"},{"element-6066-11e4-a52e-4f735466cecf":"250f4746-1eb2-4fbf-b450-8ce6e0645a00"},{"element-6066-11e4-a52e-4f735466cecf":"72a58c15-6939-4172-9e72-724719785a10"},{"element-6066-11e4-a52e-4f735466cecf":"ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"00b963a9-4c3c-43f7-8837-248d3958c0c4"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6f008a34-649c-4b53-aeb1-8103da69eaa9/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"00b963a9-4c3c-43f7-8837-248d3958c0c4"},{"element-6066-11e4-a52e-4f735466cecf":"e19bfa53-909f-41ae-affe-70889a9b4aa0"},{"element-6066-11e4-a52e-4f735466cecf":"c8e57a57-9908-43c0-bfa5-14341ba21288"},{"element-6066-11e4-a52e-4f735466cecf":"250f4746-1eb2-4fbf-b450-8ce6e0645a00"},{"element-6066-11e4-a52e-4f735466cecf":"72a58c15-6939-4172-9e72-724719785a10"},{"element-6066-11e4-a52e-4f735466cecf":"ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6f008a34-649c-4b53-aeb1-8103da69eaa9/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"00b963a9-4c3c-43f7-8837-248d3958c0c4"},{"element-6066-11e4-a52e-4f735466cecf":"e19bfa53-909f-41ae-affe-70889a9b4aa0"},{"element-6066-11e4-a52e-4f735466cecf":"c8e57a57-9908-43c0-bfa5-14341ba21288"},{"element-6066-11e4-a52e-4f735466cecf":"250f4746-1eb2-4fbf-b450-8ce6e0645a00"},{"element-6066-11e4-a52e-4f735466cecf":"72a58c15-6939-4172-9e72-724719785a10"},{"element-6066-11e4-a52e-4f735466cecf":"ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6f008a34-649c-4b53-aeb1-8103da69eaa9/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"00b963a9-4c3c-43f7-8837-248d3958c0c4"},{"element-6066-11e4-a52e-4f735466cecf":"e19bfa53-909f-41ae-affe-70889a9b4aa0"},{"element-6066-11e4-a52e-4f735466cecf":"c8e57a57-9908-43c0-bfa5-14341ba21288"},{"element-6066-11e4-a52e-4f735466cecf":"250f4746-1eb2-4fbf-b450-8ce6e0645a00"},{"element-6066-11e4-a52e-4f735466cecf":"72a58c15-6939-4172-9e72-724719785a10"},{"element-6066-11e4-a52e-4f735466cecf":"ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e19bfa53-909f-41ae-affe-70889a9b4aa0/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e19bfa53-909f-41ae-affe-70889a9b4aa0/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"7","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:14:28.319Z","end":"2023-02-17T02:14:30.650Z","_duration":2331,"uid":"73","cid":"0-0","title":"When I choose chat option \"Costs\"","fullTitle":"7: When I choose chat option \"Costs\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"00b963a9-4c3c-43f7-8837-248d3958c0c4"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"00b963a9-4c3c-43f7-8837-248d3958c0c4","ELEMENT":"00b963a9-4c3c-43f7-8837-248d3958c0c4"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"00b963a9-4c3c-43f7-8837-248d3958c0c4","ELEMENT":"00b963a9-4c3c-43f7-8837-248d3958c0c4"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"00b963a9-4c3c-43f7-8837-248d3958c0c4","ELEMENT":"00b963a9-4c3c-43f7-8837-248d3958c0c4"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"00b963a9-4c3c-43f7-8837-248d3958c0c4","ELEMENT":"00b963a9-4c3c-43f7-8837-248d3958c0c4"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"00b963a9-4c3c-43f7-8837-248d3958c0c4"},{"element-6066-11e4-a52e-4f735466cecf":"e19bfa53-909f-41ae-affe-70889a9b4aa0"},{"element-6066-11e4-a52e-4f735466cecf":"c8e57a57-9908-43c0-bfa5-14341ba21288"},{"element-6066-11e4-a52e-4f735466cecf":"250f4746-1eb2-4fbf-b450-8ce6e0645a00"},{"element-6066-11e4-a52e-4f735466cecf":"72a58c15-6939-4172-9e72-724719785a10"},{"element-6066-11e4-a52e-4f735466cecf":"ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/00b963a9-4c3c-43f7-8837-248d3958c0c4/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/00b963a9-4c3c-43f7-8837-248d3958c0c4/text","body":{},"result":{"value":"Explain chatbots"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e19bfa53-909f-41ae-affe-70889a9b4aa0/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e19bfa53-909f-41ae-affe-70889a9b4aa0/text","body":{},"result":{"value":"Make a chatbot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c8e57a57-9908-43c0-bfa5-14341ba21288/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c8e57a57-9908-43c0-bfa5-14341ba21288/text","body":{},"result":{"value":"Use cases"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/250f4746-1eb2-4fbf-b450-8ce6e0645a00/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/250f4746-1eb2-4fbf-b450-8ce6e0645a00/text","body":{},"result":{"value":"Features"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/72a58c15-6939-4172-9e72-724719785a10/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/72a58c15-6939-4172-9e72-724719785a10/text","body":{},"result":{"value":"Contact SnatchBot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50/text","body":{},"result":{"value":"Costs"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ab113913-f11a-49b2-a7dc-59e6cad3c9e9"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ab113913-f11a-49b2-a7dc-59e6cad3c9e9/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ab113913-f11a-49b2-a7dc-59e6cad3c9e9/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50/rect","body":{},"result":{"value":{"height":40,"width":68,"x":229.625,"y":448.1953125}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action15","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action15","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ded0ca3f-fe68-4db8-90d4-b20c4ddc6c50/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"7","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:14:30.650Z","end":"2023-02-17T02:14:35.610Z","_duration":4960,"uid":"74","cid":"0-0","title":"And I choose chat option \"A few\"","fullTitle":"7: And I choose chat option \"A few\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"da71a60d-b0d8-4af0-81dd-c3d417f76e53"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"da71a60d-b0d8-4af0-81dd-c3d417f76e53","ELEMENT":"da71a60d-b0d8-4af0-81dd-c3d417f76e53"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"da71a60d-b0d8-4af0-81dd-c3d417f76e53","ELEMENT":"da71a60d-b0d8-4af0-81dd-c3d417f76e53"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"da71a60d-b0d8-4af0-81dd-c3d417f76e53","ELEMENT":"da71a60d-b0d8-4af0-81dd-c3d417f76e53"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"da71a60d-b0d8-4af0-81dd-c3d417f76e53","ELEMENT":"da71a60d-b0d8-4af0-81dd-c3d417f76e53"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"da71a60d-b0d8-4af0-81dd-c3d417f76e53"},{"element-6066-11e4-a52e-4f735466cecf":"2062722d-7f76-4e6b-97af-3c4f941fee4a"},{"element-6066-11e4-a52e-4f735466cecf":"d83a9b75-3c17-4a17-b448-5e35e2f0e392"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/da71a60d-b0d8-4af0-81dd-c3d417f76e53/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/da71a60d-b0d8-4af0-81dd-c3d417f76e53/text","body":{},"result":{"value":"A few"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ab113913-f11a-49b2-a7dc-59e6cad3c9e9"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ab113913-f11a-49b2-a7dc-59e6cad3c9e9/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ab113913-f11a-49b2-a7dc-59e6cad3c9e9/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/da71a60d-b0d8-4af0-81dd-c3d417f76e53/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/da71a60d-b0d8-4af0-81dd-c3d417f76e53/rect","body":{},"result":{"value":{"height":40,"width":68,"x":70,"y":479}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action16","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"da71a60d-b0d8-4af0-81dd-c3d417f76e53"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action16","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"da71a60d-b0d8-4af0-81dd-c3d417f76e53"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/da71a60d-b0d8-4af0-81dd-c3d417f76e53/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/da71a60d-b0d8-4af0-81dd-c3d417f76e53/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2062722d-7f76-4e6b-97af-3c4f941fee4a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2062722d-7f76-4e6b-97af-3c4f941fee4a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2062722d-7f76-4e6b-97af-3c4f941fee4a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2062722d-7f76-4e6b-97af-3c4f941fee4a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9a64f9c7-c0f9-45be-909c-eb33782a943d/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9a64f9c7-c0f9-45be-909c-eb33782a943d/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d83a9b75-3c17-4a17-b448-5e35e2f0e392/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d83a9b75-3c17-4a17-b448-5e35e2f0e392/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d83a9b75-3c17-4a17-b448-5e35e2f0e392/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d83a9b75-3c17-4a17-b448-5e35e2f0e392/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d83a9b75-3c17-4a17-b448-5e35e2f0e392/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d83a9b75-3c17-4a17-b448-5e35e2f0e392/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d83a9b75-3c17-4a17-b448-5e35e2f0e392/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d83a9b75-3c17-4a17-b448-5e35e2f0e392/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/fc4deb51-3bf3-468d-8103-bf2d858a34e8/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/fc4deb51-3bf3-468d-8103-bf2d858a34e8/text","body":{},"result":{"value":"Approximately?"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"7","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:14:35.610Z","end":"2023-02-17T02:14:39.979Z","_duration":4369,"uid":"75","cid":"0-0","title":"And I choose chat option \"Approximately?\"","fullTitle":"7: And I choose chat option \"Approximately?\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8","ELEMENT":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8","ELEMENT":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8","ELEMENT":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8","ELEMENT":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"},{"element-6066-11e4-a52e-4f735466cecf":"9a64f9c7-c0f9-45be-909c-eb33782a943d"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/fc4deb51-3bf3-468d-8103-bf2d858a34e8/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/fc4deb51-3bf3-468d-8103-bf2d858a34e8/text","body":{},"result":{"value":"Approximately?"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ab113913-f11a-49b2-a7dc-59e6cad3c9e9"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ab113913-f11a-49b2-a7dc-59e6cad3c9e9/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ab113913-f11a-49b2-a7dc-59e6cad3c9e9/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/fc4deb51-3bf3-468d-8103-bf2d858a34e8/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/fc4deb51-3bf3-468d-8103-bf2d858a34e8/rect","body":{},"result":{"value":{"height":40,"width":129,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action17","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action17","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"fc4deb51-3bf3-468d-8103-bf2d858a34e8"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fc4deb51-3bf3-468d-8103-bf2d858a34e8/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fc4deb51-3bf3-468d-8103-bf2d858a34e8/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9a64f9c7-c0f9-45be-909c-eb33782a943d/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c"},{"element-6066-11e4-a52e-4f735466cecf":"a18594e7-568c-4884-a1a9-f8d1a687e2db"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9a64f9c7-c0f9-45be-909c-eb33782a943d/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c"},{"element-6066-11e4-a52e-4f735466cecf":"a18594e7-568c-4884-a1a9-f8d1a687e2db"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9a64f9c7-c0f9-45be-909c-eb33782a943d/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c"},{"element-6066-11e4-a52e-4f735466cecf":"a18594e7-568c-4884-a1a9-f8d1a687e2db"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9a64f9c7-c0f9-45be-909c-eb33782a943d/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c"},{"element-6066-11e4-a52e-4f735466cecf":"a18594e7-568c-4884-a1a9-f8d1a687e2db"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a18594e7-568c-4884-a1a9-f8d1a687e2db/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a18594e7-568c-4884-a1a9-f8d1a687e2db/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"7","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:14:39.979Z","end":"2023-02-17T02:14:44.389Z","_duration":4410,"uid":"76","cid":"0-0","title":"Then the approximate cost is \"$3,000\" with recurring fees of \"$30\" per month","fullTitle":"7: Then the approximate cost is \"$3,000\" with recurring fees of \"$30\" per month","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c","ELEMENT":"25059019-755e-49f1-a89c-28b80253863c"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c","ELEMENT":"25059019-755e-49f1-a89c-28b80253863c"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c","ELEMENT":"25059019-755e-49f1-a89c-28b80253863c"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c","ELEMENT":"25059019-755e-49f1-a89c-28b80253863c"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__body"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__body"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"705f099e-8597-4511-9302-9dc51b2f92fd"},{"element-6066-11e4-a52e-4f735466cecf":"49a4319d-8427-4ef6-9e3b-7a8dec0b3c53"},{"element-6066-11e4-a52e-4f735466cecf":"b846cdd1-5ab2-49a7-92af-ec9581b50e48"},{"element-6066-11e4-a52e-4f735466cecf":"81227cfb-fe08-4729-8dd1-f36982fb9b59"},{"element-6066-11e4-a52e-4f735466cecf":"e8380e9c-2f96-4ab7-8f4e-8daa97102da7"},{"element-6066-11e4-a52e-4f735466cecf":"7c452e51-8df0-493a-a873-cde53f80af10"},{"element-6066-11e4-a52e-4f735466cecf":"5f1e4037-98c7-40a3-ade3-6252b382b8a0"},{"element-6066-11e4-a52e-4f735466cecf":"e95a66d0-1666-4e4d-aa0f-35c90f453ed6"},{"element-6066-11e4-a52e-4f735466cecf":"b897460d-4d94-4344-89e3-c180bf7ea2c1"},{"element-6066-11e4-a52e-4f735466cecf":"959ac24f-4b81-4f47-a4fb-fb9c4025a3e7"},{"element-6066-11e4-a52e-4f735466cecf":"df526cfc-faa5-4e82-b721-0946b8fb3a86"},{"element-6066-11e4-a52e-4f735466cecf":"f93f096d-2822-49de-95ee-de26d2cf721f"},{"element-6066-11e4-a52e-4f735466cecf":"b468608b-94d9-4967-8d30-2a791c750852"},{"element-6066-11e4-a52e-4f735466cecf":"80cbfcb8-d350-4f7a-9861-0b1134ddfad1"},{"element-6066-11e4-a52e-4f735466cecf":"d68a9b9d-b1d7-4e9a-9d4c-8fd4044794f3"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d68a9b9d-b1d7-4e9a-9d4c-8fd4044794f3/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d68a9b9d-b1d7-4e9a-9d4c-8fd4044794f3/text","body":{},"result":{"value":"The good news is we are highly competitive and, typically, our chatbot builds cost around $3,000."},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c","ELEMENT":"25059019-755e-49f1-a89c-28b80253863c"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c","ELEMENT":"25059019-755e-49f1-a89c-28b80253863c"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c","ELEMENT":"25059019-755e-49f1-a89c-28b80253863c"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c","ELEMENT":"25059019-755e-49f1-a89c-28b80253863c"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c"},{"element-6066-11e4-a52e-4f735466cecf":"a18594e7-568c-4884-a1a9-f8d1a687e2db"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/25059019-755e-49f1-a89c-28b80253863c/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/25059019-755e-49f1-a89c-28b80253863c/text","body":{},"result":{"value":"Recurring fees?"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ab113913-f11a-49b2-a7dc-59e6cad3c9e9"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ab113913-f11a-49b2-a7dc-59e6cad3c9e9/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ab113913-f11a-49b2-a7dc-59e6cad3c9e9/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/25059019-755e-49f1-a89c-28b80253863c/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/25059019-755e-49f1-a89c-28b80253863c/rect","body":{},"result":{"value":{"height":40,"width":130,"x":70,"y":479}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action18","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action18","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"25059019-755e-49f1-a89c-28b80253863c"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/25059019-755e-49f1-a89c-28b80253863c/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/25059019-755e-49f1-a89c-28b80253863c/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a18594e7-568c-4884-a1a9-f8d1a687e2db/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"51a6a8ee-1541-4401-bb7b-71931ca663c9"},{"element-6066-11e4-a52e-4f735466cecf":"8dc3beca-09f5-4609-a994-bdab238c19c5"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"51a6a8ee-1541-4401-bb7b-71931ca663c9"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a18594e7-568c-4884-a1a9-f8d1a687e2db/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"51a6a8ee-1541-4401-bb7b-71931ca663c9"},{"element-6066-11e4-a52e-4f735466cecf":"8dc3beca-09f5-4609-a994-bdab238c19c5"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a18594e7-568c-4884-a1a9-f8d1a687e2db/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"51a6a8ee-1541-4401-bb7b-71931ca663c9"},{"element-6066-11e4-a52e-4f735466cecf":"8dc3beca-09f5-4609-a994-bdab238c19c5"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a18594e7-568c-4884-a1a9-f8d1a687e2db/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"51a6a8ee-1541-4401-bb7b-71931ca663c9"},{"element-6066-11e4-a52e-4f735466cecf":"8dc3beca-09f5-4609-a994-bdab238c19c5"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8dc3beca-09f5-4609-a994-bdab238c19c5/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8dc3beca-09f5-4609-a994-bdab238c19c5/text","body":{},"result":{"value":"Done"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"51a6a8ee-1541-4401-bb7b-71931ca663c9"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"51a6a8ee-1541-4401-bb7b-71931ca663c9","ELEMENT":"51a6a8ee-1541-4401-bb7b-71931ca663c9"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"51a6a8ee-1541-4401-bb7b-71931ca663c9","ELEMENT":"51a6a8ee-1541-4401-bb7b-71931ca663c9"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"51a6a8ee-1541-4401-bb7b-71931ca663c9","ELEMENT":"51a6a8ee-1541-4401-bb7b-71931ca663c9"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"51a6a8ee-1541-4401-bb7b-71931ca663c9","ELEMENT":"51a6a8ee-1541-4401-bb7b-71931ca663c9"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__body"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__body"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"705f099e-8597-4511-9302-9dc51b2f92fd"},{"element-6066-11e4-a52e-4f735466cecf":"49a4319d-8427-4ef6-9e3b-7a8dec0b3c53"},{"element-6066-11e4-a52e-4f735466cecf":"b846cdd1-5ab2-49a7-92af-ec9581b50e48"},{"element-6066-11e4-a52e-4f735466cecf":"81227cfb-fe08-4729-8dd1-f36982fb9b59"},{"element-6066-11e4-a52e-4f735466cecf":"e8380e9c-2f96-4ab7-8f4e-8daa97102da7"},{"element-6066-11e4-a52e-4f735466cecf":"7c452e51-8df0-493a-a873-cde53f80af10"},{"element-6066-11e4-a52e-4f735466cecf":"5f1e4037-98c7-40a3-ade3-6252b382b8a0"},{"element-6066-11e4-a52e-4f735466cecf":"e95a66d0-1666-4e4d-aa0f-35c90f453ed6"},{"element-6066-11e4-a52e-4f735466cecf":"b897460d-4d94-4344-89e3-c180bf7ea2c1"},{"element-6066-11e4-a52e-4f735466cecf":"959ac24f-4b81-4f47-a4fb-fb9c4025a3e7"},{"element-6066-11e4-a52e-4f735466cecf":"df526cfc-faa5-4e82-b721-0946b8fb3a86"},{"element-6066-11e4-a52e-4f735466cecf":"f93f096d-2822-49de-95ee-de26d2cf721f"},{"element-6066-11e4-a52e-4f735466cecf":"b468608b-94d9-4967-8d30-2a791c750852"},{"element-6066-11e4-a52e-4f735466cecf":"80cbfcb8-d350-4f7a-9861-0b1134ddfad1"},{"element-6066-11e4-a52e-4f735466cecf":"d68a9b9d-b1d7-4e9a-9d4c-8fd4044794f3"},{"element-6066-11e4-a52e-4f735466cecf":"676f2cce-e01c-4e47-8538-dab3b9a77964"},{"element-6066-11e4-a52e-4f735466cecf":"bcf33012-98a2-410d-bb78-b526da2b0422"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/bcf33012-98a2-410d-bb78-b526da2b0422/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/bcf33012-98a2-410d-bb78-b526da2b0422/text","body":{},"result":{"value":"Yes, there is a recurring monthly cost, which is our Pro-plan. The Pro-plan costs start at $30 a month."},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"7","state":"passed","events":[],"errorIndex":0},{"type":"hook","start":"2023-02-17T02:14:44.389Z","end":"2023-02-17T02:14:44.389Z","_duration":0,"uid":"161","cid":"0-0","title":"","parent":"7","errors":[]}]},{"type":"scenario","start":"2023-02-17T02:14:44.391Z","end":"2023-02-17T02:15:28.930Z","_duration":44536,"uid":"8","cid":"0-0","file":"/Users/jimwatkins/Workspace/fart/features/login.feature","title":"As a user I want to be able to learn in detail about chatbot features","fullTitle":"login.feature:1:1: As a user I want to be able to learn in detail about chatbot features","tags":[],"tests":[{"type":"test","start":"2023-02-17T02:14:44.391Z","end":"2023-02-17T02:14:44.392Z","_duration":1,"uid":"78","cid":"0-0","title":"Given I am on the following url https://snatchbot.me/","fullTitle":"8: Given I am on the following url https://snatchbot.me/","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"8","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:14:44.392Z","end":"2023-02-17T02:14:47.027Z","_duration":2635,"uid":"79","cid":"0-0","title":"And I click on the SnatchBot chat bot","fullTitle":"8: And I click on the SnatchBot chat bot","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9718200d-2c25-4466-b599-b2fb92b8c005"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9718200d-2c25-4466-b599-b2fb92b8c005","ELEMENT":"9718200d-2c25-4466-b599-b2fb92b8c005"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9718200d-2c25-4466-b599-b2fb92b8c005","ELEMENT":"9718200d-2c25-4466-b599-b2fb92b8c005"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9718200d-2c25-4466-b599-b2fb92b8c005","ELEMENT":"9718200d-2c25-4466-b599-b2fb92b8c005"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9718200d-2c25-4466-b599-b2fb92b8c005","ELEMENT":"9718200d-2c25-4466-b599-b2fb92b8c005"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9718200d-2c25-4466-b599-b2fb92b8c005"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9718200d-2c25-4466-b599-b2fb92b8c005/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9718200d-2c25-4466-b599-b2fb92b8c005/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"23671c60-6f2d-4efa-8bbc-c3ee9a2f9ad7"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"23671c60-6f2d-4efa-8bbc-c3ee9a2f9ad7","element-6066-11e4-a52e-4f735466cecf":"23671c60-6f2d-4efa-8bbc-c3ee9a2f9ad7","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"8","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:14:47.027Z","end":"2023-02-17T02:15:01.005Z","_duration":13978,"uid":"80","cid":"0-0","title":"And I enter my name \"John\"","fullTitle":"8: And I enter my name \"John\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"23671c60-6f2d-4efa-8bbc-c3ee9a2f9ad7","element-6066-11e4-a52e-4f735466cecf":"23671c60-6f2d-4efa-8bbc-c3ee9a2f9ad7","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\"input#chat_input\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"0518c12b-a1c8-4940-8dff-845a51fde8f1"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"0518c12b-a1c8-4940-8dff-845a51fde8f1"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0518c12b-a1c8-4940-8dff-845a51fde8f1"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0518c12b-a1c8-4940-8dff-845a51fde8f1"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/clear","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/clear","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/value","body":{"text":"John"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/value","body":{"text":"John"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action19","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action19","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9dc39930-8774-495b-a22d-9a17c54ca828"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9dc39930-8774-495b-a22d-9a17c54ca828","ELEMENT":"9dc39930-8774-495b-a22d-9a17c54ca828"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9dc39930-8774-495b-a22d-9a17c54ca828","ELEMENT":"9dc39930-8774-495b-a22d-9a17c54ca828"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9dc39930-8774-495b-a22d-9a17c54ca828","ELEMENT":"9dc39930-8774-495b-a22d-9a17c54ca828"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9dc39930-8774-495b-a22d-9a17c54ca828","ELEMENT":"9dc39930-8774-495b-a22d-9a17c54ca828"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9dc39930-8774-495b-a22d-9a17c54ca828"},{"element-6066-11e4-a52e-4f735466cecf":"a80f3748-045f-4c13-979a-10c09bd027bc"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9dc39930-8774-495b-a22d-9a17c54ca828/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9dc39930-8774-495b-a22d-9a17c54ca828/text","body":{},"result":{"value":"Yes"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e0eeb94a-ce08-4b74-bc46-678a081d3aab"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e0eeb94a-ce08-4b74-bc46-678a081d3aab/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e0eeb94a-ce08-4b74-bc46-678a081d3aab/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9dc39930-8774-495b-a22d-9a17c54ca828/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9dc39930-8774-495b-a22d-9a17c54ca828/rect","body":{},"result":{"value":{"height":40,"width":64,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action20","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"9dc39930-8774-495b-a22d-9a17c54ca828"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action20","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"9dc39930-8774-495b-a22d-9a17c54ca828"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9dc39930-8774-495b-a22d-9a17c54ca828/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9dc39930-8774-495b-a22d-9a17c54ca828/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a80f3748-045f-4c13-979a-10c09bd027bc/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"229b3583-ed8f-4165-a406-637128e6fa37"},{"element-6066-11e4-a52e-4f735466cecf":"59099aa0-8daf-48a4-b1f1-6459d1fd23be"},{"element-6066-11e4-a52e-4f735466cecf":"da190231-e10f-4449-b4d4-83d4de6a93a7"},{"element-6066-11e4-a52e-4f735466cecf":"e4f5c764-d19b-4c17-b616-850ee7e50ccc"},{"element-6066-11e4-a52e-4f735466cecf":"d280c1a6-b61f-40d9-b260-ac370917640a"},{"element-6066-11e4-a52e-4f735466cecf":"b4280f1a-12cb-4985-906e-28b76e3881bf"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"229b3583-ed8f-4165-a406-637128e6fa37"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a80f3748-045f-4c13-979a-10c09bd027bc/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"229b3583-ed8f-4165-a406-637128e6fa37"},{"element-6066-11e4-a52e-4f735466cecf":"59099aa0-8daf-48a4-b1f1-6459d1fd23be"},{"element-6066-11e4-a52e-4f735466cecf":"da190231-e10f-4449-b4d4-83d4de6a93a7"},{"element-6066-11e4-a52e-4f735466cecf":"e4f5c764-d19b-4c17-b616-850ee7e50ccc"},{"element-6066-11e4-a52e-4f735466cecf":"d280c1a6-b61f-40d9-b260-ac370917640a"},{"element-6066-11e4-a52e-4f735466cecf":"b4280f1a-12cb-4985-906e-28b76e3881bf"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a80f3748-045f-4c13-979a-10c09bd027bc/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"229b3583-ed8f-4165-a406-637128e6fa37"},{"element-6066-11e4-a52e-4f735466cecf":"59099aa0-8daf-48a4-b1f1-6459d1fd23be"},{"element-6066-11e4-a52e-4f735466cecf":"da190231-e10f-4449-b4d4-83d4de6a93a7"},{"element-6066-11e4-a52e-4f735466cecf":"e4f5c764-d19b-4c17-b616-850ee7e50ccc"},{"element-6066-11e4-a52e-4f735466cecf":"d280c1a6-b61f-40d9-b260-ac370917640a"},{"element-6066-11e4-a52e-4f735466cecf":"b4280f1a-12cb-4985-906e-28b76e3881bf"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a80f3748-045f-4c13-979a-10c09bd027bc/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"229b3583-ed8f-4165-a406-637128e6fa37"},{"element-6066-11e4-a52e-4f735466cecf":"59099aa0-8daf-48a4-b1f1-6459d1fd23be"},{"element-6066-11e4-a52e-4f735466cecf":"da190231-e10f-4449-b4d4-83d4de6a93a7"},{"element-6066-11e4-a52e-4f735466cecf":"e4f5c764-d19b-4c17-b616-850ee7e50ccc"},{"element-6066-11e4-a52e-4f735466cecf":"d280c1a6-b61f-40d9-b260-ac370917640a"},{"element-6066-11e4-a52e-4f735466cecf":"b4280f1a-12cb-4985-906e-28b76e3881bf"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/59099aa0-8daf-48a4-b1f1-6459d1fd23be/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/59099aa0-8daf-48a4-b1f1-6459d1fd23be/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"8","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:15:01.006Z","end":"2023-02-17T02:15:07.413Z","_duration":6407,"uid":"81","cid":"0-0","title":"When I choose chat option \"Features\"","fullTitle":"8: When I choose chat option \"Features\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"229b3583-ed8f-4165-a406-637128e6fa37"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"229b3583-ed8f-4165-a406-637128e6fa37","ELEMENT":"229b3583-ed8f-4165-a406-637128e6fa37"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"229b3583-ed8f-4165-a406-637128e6fa37","ELEMENT":"229b3583-ed8f-4165-a406-637128e6fa37"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"229b3583-ed8f-4165-a406-637128e6fa37","ELEMENT":"229b3583-ed8f-4165-a406-637128e6fa37"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"229b3583-ed8f-4165-a406-637128e6fa37","ELEMENT":"229b3583-ed8f-4165-a406-637128e6fa37"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"229b3583-ed8f-4165-a406-637128e6fa37"},{"element-6066-11e4-a52e-4f735466cecf":"59099aa0-8daf-48a4-b1f1-6459d1fd23be"},{"element-6066-11e4-a52e-4f735466cecf":"da190231-e10f-4449-b4d4-83d4de6a93a7"},{"element-6066-11e4-a52e-4f735466cecf":"e4f5c764-d19b-4c17-b616-850ee7e50ccc"},{"element-6066-11e4-a52e-4f735466cecf":"d280c1a6-b61f-40d9-b260-ac370917640a"},{"element-6066-11e4-a52e-4f735466cecf":"b4280f1a-12cb-4985-906e-28b76e3881bf"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/229b3583-ed8f-4165-a406-637128e6fa37/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/229b3583-ed8f-4165-a406-637128e6fa37/text","body":{},"result":{"value":"Explain chatbots"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/59099aa0-8daf-48a4-b1f1-6459d1fd23be/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/59099aa0-8daf-48a4-b1f1-6459d1fd23be/text","body":{},"result":{"value":"Make a chatbot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/da190231-e10f-4449-b4d4-83d4de6a93a7/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/da190231-e10f-4449-b4d4-83d4de6a93a7/text","body":{},"result":{"value":"Use cases"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e4f5c764-d19b-4c17-b616-850ee7e50ccc/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e4f5c764-d19b-4c17-b616-850ee7e50ccc/text","body":{},"result":{"value":"Features"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e0eeb94a-ce08-4b74-bc46-678a081d3aab"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e0eeb94a-ce08-4b74-bc46-678a081d3aab/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e0eeb94a-ce08-4b74-bc46-678a081d3aab/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e4f5c764-d19b-4c17-b616-850ee7e50ccc/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e4f5c764-d19b-4c17-b616-850ee7e50ccc/rect","body":{},"result":{"value":{"height":40,"width":87,"x":461.03125,"y":398}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action21","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"e4f5c764-d19b-4c17-b616-850ee7e50ccc"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action21","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"e4f5c764-d19b-4c17-b616-850ee7e50ccc"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e4f5c764-d19b-4c17-b616-850ee7e50ccc/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e4f5c764-d19b-4c17-b616-850ee7e50ccc/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8/text","body":{},"result":{"value":"Absolutely"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8/text","body":{},"result":{"value":"Absolutely"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"8","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:15:07.413Z","end":"2023-02-17T02:15:12.867Z","_duration":5454,"uid":"82","cid":"0-0","title":"And I choose chat option \"Absolutely\"","fullTitle":"8: And I choose chat option \"Absolutely\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8","ELEMENT":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8","ELEMENT":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8","ELEMENT":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8","ELEMENT":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8/text","body":{},"result":{"value":"Absolutely"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e0eeb94a-ce08-4b74-bc46-678a081d3aab"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e0eeb94a-ce08-4b74-bc46-678a081d3aab/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e0eeb94a-ce08-4b74-bc46-678a081d3aab/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8/rect","body":{},"result":{"value":{"height":40,"width":98,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action22","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action22","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/75a54188-4e7a-4f1b-8115-e0b976639f44/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/75a54188-4e7a-4f1b-8115-e0b976639f44/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/75a54188-4e7a-4f1b-8115-e0b976639f44/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/75a54188-4e7a-4f1b-8115-e0b976639f44/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e773f99f-b1e8-4d9b-9be5-9a5daed26eb8/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e773f99f-b1e8-4d9b-9be5-9a5daed26eb8/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/16b67e25-9a41-4f47-9c24-a7a394cccf98/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/16b67e25-9a41-4f47-9c24-a7a394cccf98/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/16b67e25-9a41-4f47-9c24-a7a394cccf98/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/16b67e25-9a41-4f47-9c24-a7a394cccf98/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/16b67e25-9a41-4f47-9c24-a7a394cccf98/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/16b67e25-9a41-4f47-9c24-a7a394cccf98/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/16b67e25-9a41-4f47-9c24-a7a394cccf98/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/16b67e25-9a41-4f47-9c24-a7a394cccf98/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3ba72f28-b6ae-490d-a96f-8bc5037b7c1e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3ba72f28-b6ae-490d-a96f-8bc5037b7c1e/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"8","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:15:12.867Z","end":"2023-02-17T02:15:18.867Z","_duration":6000,"uid":"83","cid":"0-0","title":"And I choose chat option \"Great!\"","fullTitle":"8: And I choose chat option \"Great!\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522","ELEMENT":"3b6156b9-00e7-4822-af26-631f36a9c522"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522","ELEMENT":"3b6156b9-00e7-4822-af26-631f36a9c522"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522","ELEMENT":"3b6156b9-00e7-4822-af26-631f36a9c522"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522","ELEMENT":"3b6156b9-00e7-4822-af26-631f36a9c522"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3b6156b9-00e7-4822-af26-631f36a9c522/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3b6156b9-00e7-4822-af26-631f36a9c522/text","body":{},"result":{"value":"Great!"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e0eeb94a-ce08-4b74-bc46-678a081d3aab"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e0eeb94a-ce08-4b74-bc46-678a081d3aab/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e0eeb94a-ce08-4b74-bc46-678a081d3aab/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3b6156b9-00e7-4822-af26-631f36a9c522/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3b6156b9-00e7-4822-af26-631f36a9c522/rect","body":{},"result":{"value":{"height":40,"width":70,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action23","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action23","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/3b6156b9-00e7-4822-af26-631f36a9c522/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/3b6156b9-00e7-4822-af26-631f36a9c522/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e773f99f-b1e8-4d9b-9be5-9a5daed26eb8/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e773f99f-b1e8-4d9b-9be5-9a5daed26eb8/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e773f99f-b1e8-4d9b-9be5-9a5daed26eb8/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e773f99f-b1e8-4d9b-9be5-9a5daed26eb8/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1ecd592b-0335-4f80-b038-1e548051552a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1ecd592b-0335-4f80-b038-1e548051552a/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3ba72f28-b6ae-490d-a96f-8bc5037b7c1e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3ba72f28-b6ae-490d-a96f-8bc5037b7c1e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3ba72f28-b6ae-490d-a96f-8bc5037b7c1e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3ba72f28-b6ae-490d-a96f-8bc5037b7c1e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3ba72f28-b6ae-490d-a96f-8bc5037b7c1e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3ba72f28-b6ae-490d-a96f-8bc5037b7c1e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3ba72f28-b6ae-490d-a96f-8bc5037b7c1e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3ba72f28-b6ae-490d-a96f-8bc5037b7c1e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9e4827c2-0b54-4081-9d68-87dd2f13953e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9e4827c2-0b54-4081-9d68-87dd2f13953e/text","body":{},"result":{"value":"Go!"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"8","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:15:18.868Z","end":"2023-02-17T02:15:23.744Z","_duration":4876,"uid":"84","cid":"0-0","title":"And I choose chat option \"Go!\"","fullTitle":"8: And I choose chat option \"Go!\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e","ELEMENT":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e","ELEMENT":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e","ELEMENT":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e","ELEMENT":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9e4827c2-0b54-4081-9d68-87dd2f13953e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9e4827c2-0b54-4081-9d68-87dd2f13953e/text","body":{},"result":{"value":"Go!"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e0eeb94a-ce08-4b74-bc46-678a081d3aab"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e0eeb94a-ce08-4b74-bc46-678a081d3aab/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e0eeb94a-ce08-4b74-bc46-678a081d3aab/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9e4827c2-0b54-4081-9d68-87dd2f13953e/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9e4827c2-0b54-4081-9d68-87dd2f13953e/rect","body":{},"result":{"value":{"height":40,"width":64,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action24","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action24","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9e4827c2-0b54-4081-9d68-87dd2f13953e/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9e4827c2-0b54-4081-9d68-87dd2f13953e/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1ecd592b-0335-4f80-b038-1e548051552a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"},{"element-6066-11e4-a52e-4f735466cecf":"6de9db89-f4e9-43ef-ba68-64b00fe606e4"},{"element-6066-11e4-a52e-4f735466cecf":"ddbd4de2-9619-4c76-8ea7-ebae60f95006"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1ecd592b-0335-4f80-b038-1e548051552a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"},{"element-6066-11e4-a52e-4f735466cecf":"6de9db89-f4e9-43ef-ba68-64b00fe606e4"},{"element-6066-11e4-a52e-4f735466cecf":"ddbd4de2-9619-4c76-8ea7-ebae60f95006"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1ecd592b-0335-4f80-b038-1e548051552a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"},{"element-6066-11e4-a52e-4f735466cecf":"6de9db89-f4e9-43ef-ba68-64b00fe606e4"},{"element-6066-11e4-a52e-4f735466cecf":"ddbd4de2-9619-4c76-8ea7-ebae60f95006"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1ecd592b-0335-4f80-b038-1e548051552a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"},{"element-6066-11e4-a52e-4f735466cecf":"6de9db89-f4e9-43ef-ba68-64b00fe606e4"},{"element-6066-11e4-a52e-4f735466cecf":"ddbd4de2-9619-4c76-8ea7-ebae60f95006"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6de9db89-f4e9-43ef-ba68-64b00fe606e4/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/6de9db89-f4e9-43ef-ba68-64b00fe606e4/text","body":{},"result":{"value":"Feature 2"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"8","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:15:23.745Z","end":"2023-02-17T02:15:23.775Z","_duration":30,"uid":"85","cid":"0-0","title":"Then the chatbot lists feature \"Natural Language Processing or just NLP\"","fullTitle":"8: Then the chatbot lists feature \"Natural Language Processing or just NLP\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0","ELEMENT":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0","ELEMENT":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0","ELEMENT":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0","ELEMENT":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__body"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__body"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"2da1124b-2cb2-4f24-a5b1-393ba4e6fd6a"},{"element-6066-11e4-a52e-4f735466cecf":"9c385a87-41fb-4217-84b6-77dada07e73b"},{"element-6066-11e4-a52e-4f735466cecf":"532658de-c89a-4e10-b024-a60cf99ec760"},{"element-6066-11e4-a52e-4f735466cecf":"86c3da71-c0ca-46fb-90c5-b7cde2a9a804"},{"element-6066-11e4-a52e-4f735466cecf":"ea29a7d0-6161-4166-b931-a70f3f9c106d"},{"element-6066-11e4-a52e-4f735466cecf":"5627968b-719c-4e9f-b05f-093b6dbc32ba"},{"element-6066-11e4-a52e-4f735466cecf":"90a990d0-74fd-43e6-9ab2-1a9d4815a07e"},{"element-6066-11e4-a52e-4f735466cecf":"5e6e63b8-c291-4108-aeba-9408f8cb97c9"},{"element-6066-11e4-a52e-4f735466cecf":"211f43f2-97d0-472e-8345-1ccb10d92df6"},{"element-6066-11e4-a52e-4f735466cecf":"1ef28e97-60e2-476b-8ad9-1c6e54f69367"},{"element-6066-11e4-a52e-4f735466cecf":"0fad5a93-8543-444a-9c41-d54626a4b119"},{"element-6066-11e4-a52e-4f735466cecf":"83c875cd-02c5-4463-9ae7-91ec8dccc3d1"},{"element-6066-11e4-a52e-4f735466cecf":"9d28a29a-71a4-4b90-99fc-b947dcf63e4d"},{"element-6066-11e4-a52e-4f735466cecf":"c28841af-e5ab-4330-9c81-ef8ae91fa5aa"},{"element-6066-11e4-a52e-4f735466cecf":"81621fd1-f0b1-4a85-b9ed-ee5db8b9ada1"},{"element-6066-11e4-a52e-4f735466cecf":"0937c2af-2822-40ef-a1e0-ed4e7b5b7ae6"},{"element-6066-11e4-a52e-4f735466cecf":"8a6de678-788b-43e2-9ac4-e18fe025887a"},{"element-6066-11e4-a52e-4f735466cecf":"0a53c3da-196c-4705-86ff-5f80b3ca61af"},{"element-6066-11e4-a52e-4f735466cecf":"a361689f-1644-40ac-93ee-3203b60a6914"},{"element-6066-11e4-a52e-4f735466cecf":"2f208d75-574e-4cbf-bc78-13048c18691d"},{"element-6066-11e4-a52e-4f735466cecf":"6610b370-442e-4565-b932-1dfe4b03e1b3"},{"element-6066-11e4-a52e-4f735466cecf":"d680a926-61e3-4598-8998-a150005c3fed"},{"element-6066-11e4-a52e-4f735466cecf":"d8512bf8-50ed-440a-8f40-6fd12ff89ba1"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d8512bf8-50ed-440a-8f40-6fd12ff89ba1/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d8512bf8-50ed-440a-8f40-6fd12ff89ba1/text","body":{},"result":{"value":"Natural Language Processing or just NLP"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"8","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:15:23.775Z","end":"2023-02-17T02:15:28.748Z","_duration":4973,"uid":"86","cid":"0-0","title":"And I choose chat option \"More\"","fullTitle":"8: And I choose chat option \"More\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0","ELEMENT":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0","ELEMENT":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0","ELEMENT":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0","ELEMENT":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"},{"element-6066-11e4-a52e-4f735466cecf":"6de9db89-f4e9-43ef-ba68-64b00fe606e4"},{"element-6066-11e4-a52e-4f735466cecf":"ddbd4de2-9619-4c76-8ea7-ebae60f95006"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a05f0b34-4d1c-4643-8f09-4b60301eadb0/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a05f0b34-4d1c-4643-8f09-4b60301eadb0/text","body":{},"result":{"value":"More"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e0eeb94a-ce08-4b74-bc46-678a081d3aab"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e0eeb94a-ce08-4b74-bc46-678a081d3aab/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e0eeb94a-ce08-4b74-bc46-678a081d3aab/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a05f0b34-4d1c-4643-8f09-4b60301eadb0/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a05f0b34-4d1c-4643-8f09-4b60301eadb0/rect","body":{},"result":{"value":{"height":40,"width":65,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action25","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action25","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a05f0b34-4d1c-4643-8f09-4b60301eadb0/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a05f0b34-4d1c-4643-8f09-4b60301eadb0/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6de9db89-f4e9-43ef-ba68-64b00fe606e4/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"},{"element-6066-11e4-a52e-4f735466cecf":"c003da0e-9242-4d4e-b505-aaf81513d373"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6de9db89-f4e9-43ef-ba68-64b00fe606e4/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"},{"element-6066-11e4-a52e-4f735466cecf":"c003da0e-9242-4d4e-b505-aaf81513d373"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6de9db89-f4e9-43ef-ba68-64b00fe606e4/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"},{"element-6066-11e4-a52e-4f735466cecf":"c003da0e-9242-4d4e-b505-aaf81513d373"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6de9db89-f4e9-43ef-ba68-64b00fe606e4/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"},{"element-6066-11e4-a52e-4f735466cecf":"c003da0e-9242-4d4e-b505-aaf81513d373"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c003da0e-9242-4d4e-b505-aaf81513d373/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c003da0e-9242-4d4e-b505-aaf81513d373/text","body":{},"result":{"value":"No"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ddbd4de2-9619-4c76-8ea7-ebae60f95006/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"},{"element-6066-11e4-a52e-4f735466cecf":"c003da0e-9242-4d4e-b505-aaf81513d373"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ddbd4de2-9619-4c76-8ea7-ebae60f95006/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"},{"element-6066-11e4-a52e-4f735466cecf":"c003da0e-9242-4d4e-b505-aaf81513d373"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ddbd4de2-9619-4c76-8ea7-ebae60f95006/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"},{"element-6066-11e4-a52e-4f735466cecf":"c003da0e-9242-4d4e-b505-aaf81513d373"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ddbd4de2-9619-4c76-8ea7-ebae60f95006/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"},{"element-6066-11e4-a52e-4f735466cecf":"c003da0e-9242-4d4e-b505-aaf81513d373"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ddbd4de2-9619-4c76-8ea7-ebae60f95006/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"},{"element-6066-11e4-a52e-4f735466cecf":"c003da0e-9242-4d4e-b505-aaf81513d373"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ddbd4de2-9619-4c76-8ea7-ebae60f95006/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"},{"element-6066-11e4-a52e-4f735466cecf":"c003da0e-9242-4d4e-b505-aaf81513d373"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ddbd4de2-9619-4c76-8ea7-ebae60f95006/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"},{"element-6066-11e4-a52e-4f735466cecf":"c003da0e-9242-4d4e-b505-aaf81513d373"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ddbd4de2-9619-4c76-8ea7-ebae60f95006/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"},{"element-6066-11e4-a52e-4f735466cecf":"c003da0e-9242-4d4e-b505-aaf81513d373"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/46e514e9-880a-4d02-a550-a3416e60d438/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/46e514e9-880a-4d02-a550-a3416e60d438/text","body":{},"result":{"value":"Yes"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"8","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:15:28.748Z","end":"2023-02-17T02:15:28.927Z","_duration":179,"uid":"87","cid":"0-0","title":"Then the chatbox explains the feature, \"NLP means that the chatbot can process what someone tells it in natural language and determine what is the intent of the other party and what objects or entities are involved.\"","fullTitle":"8: Then the chatbox explains the feature, \"NLP means that the chatbot can process what someone tells it in natural language and determine what is the intent of the other party and what objects or entities are involved.\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438","ELEMENT":"46e514e9-880a-4d02-a550-a3416e60d438"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438","ELEMENT":"46e514e9-880a-4d02-a550-a3416e60d438"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438","ELEMENT":"46e514e9-880a-4d02-a550-a3416e60d438"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438","ELEMENT":"46e514e9-880a-4d02-a550-a3416e60d438"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__body"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__body"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"2da1124b-2cb2-4f24-a5b1-393ba4e6fd6a"},{"element-6066-11e4-a52e-4f735466cecf":"9c385a87-41fb-4217-84b6-77dada07e73b"},{"element-6066-11e4-a52e-4f735466cecf":"532658de-c89a-4e10-b024-a60cf99ec760"},{"element-6066-11e4-a52e-4f735466cecf":"86c3da71-c0ca-46fb-90c5-b7cde2a9a804"},{"element-6066-11e4-a52e-4f735466cecf":"ea29a7d0-6161-4166-b931-a70f3f9c106d"},{"element-6066-11e4-a52e-4f735466cecf":"5627968b-719c-4e9f-b05f-093b6dbc32ba"},{"element-6066-11e4-a52e-4f735466cecf":"90a990d0-74fd-43e6-9ab2-1a9d4815a07e"},{"element-6066-11e4-a52e-4f735466cecf":"5e6e63b8-c291-4108-aeba-9408f8cb97c9"},{"element-6066-11e4-a52e-4f735466cecf":"211f43f2-97d0-472e-8345-1ccb10d92df6"},{"element-6066-11e4-a52e-4f735466cecf":"1ef28e97-60e2-476b-8ad9-1c6e54f69367"},{"element-6066-11e4-a52e-4f735466cecf":"0fad5a93-8543-444a-9c41-d54626a4b119"},{"element-6066-11e4-a52e-4f735466cecf":"83c875cd-02c5-4463-9ae7-91ec8dccc3d1"},{"element-6066-11e4-a52e-4f735466cecf":"9d28a29a-71a4-4b90-99fc-b947dcf63e4d"},{"element-6066-11e4-a52e-4f735466cecf":"c28841af-e5ab-4330-9c81-ef8ae91fa5aa"},{"element-6066-11e4-a52e-4f735466cecf":"81621fd1-f0b1-4a85-b9ed-ee5db8b9ada1"},{"element-6066-11e4-a52e-4f735466cecf":"0937c2af-2822-40ef-a1e0-ed4e7b5b7ae6"},{"element-6066-11e4-a52e-4f735466cecf":"8a6de678-788b-43e2-9ac4-e18fe025887a"},{"element-6066-11e4-a52e-4f735466cecf":"0a53c3da-196c-4705-86ff-5f80b3ca61af"},{"element-6066-11e4-a52e-4f735466cecf":"a361689f-1644-40ac-93ee-3203b60a6914"},{"element-6066-11e4-a52e-4f735466cecf":"2f208d75-574e-4cbf-bc78-13048c18691d"},{"element-6066-11e4-a52e-4f735466cecf":"6610b370-442e-4565-b932-1dfe4b03e1b3"},{"element-6066-11e4-a52e-4f735466cecf":"d680a926-61e3-4598-8998-a150005c3fed"},{"element-6066-11e4-a52e-4f735466cecf":"d8512bf8-50ed-440a-8f40-6fd12ff89ba1"},{"element-6066-11e4-a52e-4f735466cecf":"48d34b9f-d85b-4641-86bf-68267e12c44b"},{"element-6066-11e4-a52e-4f735466cecf":"19030921-c790-4be2-8a87-c8828ba04daa"},{"element-6066-11e4-a52e-4f735466cecf":"84a39ccd-8452-49fd-83c6-4315683e6f56"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2da1124b-2cb2-4f24-a5b1-393ba4e6fd6a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/2da1124b-2cb2-4f24-a5b1-393ba4e6fd6a/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9c385a87-41fb-4217-84b6-77dada07e73b/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9c385a87-41fb-4217-84b6-77dada07e73b/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/532658de-c89a-4e10-b024-a60cf99ec760/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/532658de-c89a-4e10-b024-a60cf99ec760/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/86c3da71-c0ca-46fb-90c5-b7cde2a9a804/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/86c3da71-c0ca-46fb-90c5-b7cde2a9a804/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ea29a7d0-6161-4166-b931-a70f3f9c106d/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ea29a7d0-6161-4166-b931-a70f3f9c106d/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5627968b-719c-4e9f-b05f-093b6dbc32ba/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5627968b-719c-4e9f-b05f-093b6dbc32ba/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/90a990d0-74fd-43e6-9ab2-1a9d4815a07e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/90a990d0-74fd-43e6-9ab2-1a9d4815a07e/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5e6e63b8-c291-4108-aeba-9408f8cb97c9/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5e6e63b8-c291-4108-aeba-9408f8cb97c9/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/211f43f2-97d0-472e-8345-1ccb10d92df6/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/211f43f2-97d0-472e-8345-1ccb10d92df6/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1ef28e97-60e2-476b-8ad9-1c6e54f69367/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1ef28e97-60e2-476b-8ad9-1c6e54f69367/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0fad5a93-8543-444a-9c41-d54626a4b119/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0fad5a93-8543-444a-9c41-d54626a4b119/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/83c875cd-02c5-4463-9ae7-91ec8dccc3d1/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/83c875cd-02c5-4463-9ae7-91ec8dccc3d1/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9d28a29a-71a4-4b90-99fc-b947dcf63e4d/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9d28a29a-71a4-4b90-99fc-b947dcf63e4d/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c28841af-e5ab-4330-9c81-ef8ae91fa5aa/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c28841af-e5ab-4330-9c81-ef8ae91fa5aa/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/81621fd1-f0b1-4a85-b9ed-ee5db8b9ada1/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/81621fd1-f0b1-4a85-b9ed-ee5db8b9ada1/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0937c2af-2822-40ef-a1e0-ed4e7b5b7ae6/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0937c2af-2822-40ef-a1e0-ed4e7b5b7ae6/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8a6de678-788b-43e2-9ac4-e18fe025887a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8a6de678-788b-43e2-9ac4-e18fe025887a/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0a53c3da-196c-4705-86ff-5f80b3ca61af/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0a53c3da-196c-4705-86ff-5f80b3ca61af/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a361689f-1644-40ac-93ee-3203b60a6914/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a361689f-1644-40ac-93ee-3203b60a6914/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2f208d75-574e-4cbf-bc78-13048c18691d/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/2f208d75-574e-4cbf-bc78-13048c18691d/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6610b370-442e-4565-b932-1dfe4b03e1b3/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/6610b370-442e-4565-b932-1dfe4b03e1b3/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d680a926-61e3-4598-8998-a150005c3fed/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d680a926-61e3-4598-8998-a150005c3fed/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d8512bf8-50ed-440a-8f40-6fd12ff89ba1/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d8512bf8-50ed-440a-8f40-6fd12ff89ba1/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/48d34b9f-d85b-4641-86bf-68267e12c44b/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/48d34b9f-d85b-4641-86bf-68267e12c44b/text","body":{},"result":{"value":"More"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/19030921-c790-4be2-8a87-c8828ba04daa/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/19030921-c790-4be2-8a87-c8828ba04daa/text","body":{},"result":{"value":"NLP means that the chatbot can process what someone tells it in natural language and determine what is the intent of the other party and what objects or entities are involved."},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/84a39ccd-8452-49fd-83c6-4315683e6f56/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/84a39ccd-8452-49fd-83c6-4315683e6f56/text","body":{},"result":{"value":"John, would you like an example?"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"8","state":"passed","events":[],"errorIndex":0}],"hooks":[{"type":"hook","start":"2023-02-17T02:14:44.391Z","end":"2023-02-17T02:14:44.391Z","_duration":0,"uid":"163","cid":"0-0","title":"","parent":"8","errors":[]},{"type":"hook","start":"2023-02-17T02:15:28.927Z","end":"2023-02-17T02:15:28.927Z","_duration":0,"uid":"174","cid":"0-0","title":"","parent":"8","errors":[]}],"suites":[],"parent":"login.feature:1:1","hooksAndTests":[{"type":"hook","start":"2023-02-17T02:14:44.391Z","end":"2023-02-17T02:14:44.391Z","_duration":0,"uid":"163","cid":"0-0","title":"","parent":"8","errors":[]},{"type":"test","start":"2023-02-17T02:14:44.391Z","end":"2023-02-17T02:14:44.392Z","_duration":1,"uid":"78","cid":"0-0","title":"Given I am on the following url https://snatchbot.me/","fullTitle":"8: Given I am on the following url https://snatchbot.me/","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"8","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:14:44.392Z","end":"2023-02-17T02:14:47.027Z","_duration":2635,"uid":"79","cid":"0-0","title":"And I click on the SnatchBot chat bot","fullTitle":"8: And I click on the SnatchBot chat bot","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://snatchbot.me/"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9718200d-2c25-4466-b599-b2fb92b8c005"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9718200d-2c25-4466-b599-b2fb92b8c005","ELEMENT":"9718200d-2c25-4466-b599-b2fb92b8c005"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9718200d-2c25-4466-b599-b2fb92b8c005","ELEMENT":"9718200d-2c25-4466-b599-b2fb92b8c005"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9718200d-2c25-4466-b599-b2fb92b8c005","ELEMENT":"9718200d-2c25-4466-b599-b2fb92b8c005"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9718200d-2c25-4466-b599-b2fb92b8c005","ELEMENT":"9718200d-2c25-4466-b599-b2fb92b8c005"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9718200d-2c25-4466-b599-b2fb92b8c005"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9718200d-2c25-4466-b599-b2fb92b8c005/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9718200d-2c25-4466-b599-b2fb92b8c005/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sntch_iframe"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"23671c60-6f2d-4efa-8bbc-c3ee9a2f9ad7"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"23671c60-6f2d-4efa-8bbc-c3ee9a2f9ad7","element-6066-11e4-a52e-4f735466cecf":"23671c60-6f2d-4efa-8bbc-c3ee9a2f9ad7","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"}],"retries":0,"parent":"8","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:14:47.027Z","end":"2023-02-17T02:15:01.005Z","_duration":13978,"uid":"80","cid":"0-0","title":"And I enter my name \"John\"","fullTitle":"8: And I enter my name \"John\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/frame","body":{"id":{"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","elementId":"23671c60-6f2d-4efa-8bbc-c3ee9a2f9ad7","element-6066-11e4-a52e-4f735466cecf":"23671c60-6f2d-4efa-8bbc-c3ee9a2f9ad7","selector":"#sntch_iframe","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"110.0.5481.77","chrome":{"chromedriverVersion":"110.0.5481.77 (65ed616c6e8ee3fe0ad64fe83796c020644d42af-refs/branch-heads/5481@{#839})","userDataDir":"/var/folders/rq/g2cgt_2x1tn83h89sjk_g57h0000gn/T/.com.google.Chrome.A0iWnU"},"goog:chromeOptions":{"debuggerAddress":"localhost:59690"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true}},"isReactElement":false}},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\"input#chat_input\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"0518c12b-a1c8-4940-8dff-845a51fde8f1"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"0518c12b-a1c8-4940-8dff-845a51fde8f1"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0518c12b-a1c8-4940-8dff-845a51fde8f1"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"result":{"value":false},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/enabled","body":{},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input#chat_input"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0518c12b-a1c8-4940-8dff-845a51fde8f1"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/clear","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/clear","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/value","body":{"text":"John"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0518c12b-a1c8-4940-8dff-845a51fde8f1/value","body":{"text":"John"},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action19","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action19","type":"key","parameters":{},"actions":[{"type":"keyDown","value":""},{"type":"pause","duration":10},{"type":"keyUp","value":""}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9dc39930-8774-495b-a22d-9a17c54ca828"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9dc39930-8774-495b-a22d-9a17c54ca828","ELEMENT":"9dc39930-8774-495b-a22d-9a17c54ca828"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9dc39930-8774-495b-a22d-9a17c54ca828","ELEMENT":"9dc39930-8774-495b-a22d-9a17c54ca828"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9dc39930-8774-495b-a22d-9a17c54ca828","ELEMENT":"9dc39930-8774-495b-a22d-9a17c54ca828"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9dc39930-8774-495b-a22d-9a17c54ca828","ELEMENT":"9dc39930-8774-495b-a22d-9a17c54ca828"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9dc39930-8774-495b-a22d-9a17c54ca828"},{"element-6066-11e4-a52e-4f735466cecf":"a80f3748-045f-4c13-979a-10c09bd027bc"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9dc39930-8774-495b-a22d-9a17c54ca828/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9dc39930-8774-495b-a22d-9a17c54ca828/text","body":{},"result":{"value":"Yes"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e0eeb94a-ce08-4b74-bc46-678a081d3aab"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e0eeb94a-ce08-4b74-bc46-678a081d3aab/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e0eeb94a-ce08-4b74-bc46-678a081d3aab/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9dc39930-8774-495b-a22d-9a17c54ca828/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9dc39930-8774-495b-a22d-9a17c54ca828/rect","body":{},"result":{"value":{"height":40,"width":64,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action20","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"9dc39930-8774-495b-a22d-9a17c54ca828"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action20","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"9dc39930-8774-495b-a22d-9a17c54ca828"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9dc39930-8774-495b-a22d-9a17c54ca828/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9dc39930-8774-495b-a22d-9a17c54ca828/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a80f3748-045f-4c13-979a-10c09bd027bc/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"229b3583-ed8f-4165-a406-637128e6fa37"},{"element-6066-11e4-a52e-4f735466cecf":"59099aa0-8daf-48a4-b1f1-6459d1fd23be"},{"element-6066-11e4-a52e-4f735466cecf":"da190231-e10f-4449-b4d4-83d4de6a93a7"},{"element-6066-11e4-a52e-4f735466cecf":"e4f5c764-d19b-4c17-b616-850ee7e50ccc"},{"element-6066-11e4-a52e-4f735466cecf":"d280c1a6-b61f-40d9-b260-ac370917640a"},{"element-6066-11e4-a52e-4f735466cecf":"b4280f1a-12cb-4985-906e-28b76e3881bf"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"229b3583-ed8f-4165-a406-637128e6fa37"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a80f3748-045f-4c13-979a-10c09bd027bc/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"229b3583-ed8f-4165-a406-637128e6fa37"},{"element-6066-11e4-a52e-4f735466cecf":"59099aa0-8daf-48a4-b1f1-6459d1fd23be"},{"element-6066-11e4-a52e-4f735466cecf":"da190231-e10f-4449-b4d4-83d4de6a93a7"},{"element-6066-11e4-a52e-4f735466cecf":"e4f5c764-d19b-4c17-b616-850ee7e50ccc"},{"element-6066-11e4-a52e-4f735466cecf":"d280c1a6-b61f-40d9-b260-ac370917640a"},{"element-6066-11e4-a52e-4f735466cecf":"b4280f1a-12cb-4985-906e-28b76e3881bf"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a80f3748-045f-4c13-979a-10c09bd027bc/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"229b3583-ed8f-4165-a406-637128e6fa37"},{"element-6066-11e4-a52e-4f735466cecf":"59099aa0-8daf-48a4-b1f1-6459d1fd23be"},{"element-6066-11e4-a52e-4f735466cecf":"da190231-e10f-4449-b4d4-83d4de6a93a7"},{"element-6066-11e4-a52e-4f735466cecf":"e4f5c764-d19b-4c17-b616-850ee7e50ccc"},{"element-6066-11e4-a52e-4f735466cecf":"d280c1a6-b61f-40d9-b260-ac370917640a"},{"element-6066-11e4-a52e-4f735466cecf":"b4280f1a-12cb-4985-906e-28b76e3881bf"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a80f3748-045f-4c13-979a-10c09bd027bc/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"229b3583-ed8f-4165-a406-637128e6fa37"},{"element-6066-11e4-a52e-4f735466cecf":"59099aa0-8daf-48a4-b1f1-6459d1fd23be"},{"element-6066-11e4-a52e-4f735466cecf":"da190231-e10f-4449-b4d4-83d4de6a93a7"},{"element-6066-11e4-a52e-4f735466cecf":"e4f5c764-d19b-4c17-b616-850ee7e50ccc"},{"element-6066-11e4-a52e-4f735466cecf":"d280c1a6-b61f-40d9-b260-ac370917640a"},{"element-6066-11e4-a52e-4f735466cecf":"b4280f1a-12cb-4985-906e-28b76e3881bf"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/59099aa0-8daf-48a4-b1f1-6459d1fd23be/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/59099aa0-8daf-48a4-b1f1-6459d1fd23be/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"8","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:15:01.006Z","end":"2023-02-17T02:15:07.413Z","_duration":6407,"uid":"81","cid":"0-0","title":"When I choose chat option \"Features\"","fullTitle":"8: When I choose chat option \"Features\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"229b3583-ed8f-4165-a406-637128e6fa37"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"229b3583-ed8f-4165-a406-637128e6fa37","ELEMENT":"229b3583-ed8f-4165-a406-637128e6fa37"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"229b3583-ed8f-4165-a406-637128e6fa37","ELEMENT":"229b3583-ed8f-4165-a406-637128e6fa37"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"229b3583-ed8f-4165-a406-637128e6fa37","ELEMENT":"229b3583-ed8f-4165-a406-637128e6fa37"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"229b3583-ed8f-4165-a406-637128e6fa37","ELEMENT":"229b3583-ed8f-4165-a406-637128e6fa37"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"229b3583-ed8f-4165-a406-637128e6fa37"},{"element-6066-11e4-a52e-4f735466cecf":"59099aa0-8daf-48a4-b1f1-6459d1fd23be"},{"element-6066-11e4-a52e-4f735466cecf":"da190231-e10f-4449-b4d4-83d4de6a93a7"},{"element-6066-11e4-a52e-4f735466cecf":"e4f5c764-d19b-4c17-b616-850ee7e50ccc"},{"element-6066-11e4-a52e-4f735466cecf":"d280c1a6-b61f-40d9-b260-ac370917640a"},{"element-6066-11e4-a52e-4f735466cecf":"b4280f1a-12cb-4985-906e-28b76e3881bf"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/229b3583-ed8f-4165-a406-637128e6fa37/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/229b3583-ed8f-4165-a406-637128e6fa37/text","body":{},"result":{"value":"Explain chatbots"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/59099aa0-8daf-48a4-b1f1-6459d1fd23be/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/59099aa0-8daf-48a4-b1f1-6459d1fd23be/text","body":{},"result":{"value":"Make a chatbot"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/da190231-e10f-4449-b4d4-83d4de6a93a7/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/da190231-e10f-4449-b4d4-83d4de6a93a7/text","body":{},"result":{"value":"Use cases"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e4f5c764-d19b-4c17-b616-850ee7e50ccc/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e4f5c764-d19b-4c17-b616-850ee7e50ccc/text","body":{},"result":{"value":"Features"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e0eeb94a-ce08-4b74-bc46-678a081d3aab"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e0eeb94a-ce08-4b74-bc46-678a081d3aab/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e0eeb94a-ce08-4b74-bc46-678a081d3aab/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e4f5c764-d19b-4c17-b616-850ee7e50ccc/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e4f5c764-d19b-4c17-b616-850ee7e50ccc/rect","body":{},"result":{"value":{"height":40,"width":87,"x":461.03125,"y":398}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action21","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"e4f5c764-d19b-4c17-b616-850ee7e50ccc"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action21","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"e4f5c764-d19b-4c17-b616-850ee7e50ccc"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e4f5c764-d19b-4c17-b616-850ee7e50ccc/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e4f5c764-d19b-4c17-b616-850ee7e50ccc/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d280c1a6-b61f-40d9-b260-ac370917640a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8/text","body":{},"result":{"value":"Absolutely"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b4280f1a-12cb-4985-906e-28b76e3881bf/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8/text","body":{},"result":{"value":"Absolutely"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"8","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:15:07.413Z","end":"2023-02-17T02:15:12.867Z","_duration":5454,"uid":"82","cid":"0-0","title":"And I choose chat option \"Absolutely\"","fullTitle":"8: And I choose chat option \"Absolutely\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8","ELEMENT":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8","ELEMENT":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8","ELEMENT":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8","ELEMENT":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"},{"element-6066-11e4-a52e-4f735466cecf":"75a54188-4e7a-4f1b-8115-e0b976639f44"},{"element-6066-11e4-a52e-4f735466cecf":"16b67e25-9a41-4f47-9c24-a7a394cccf98"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8/text","body":{},"result":{"value":"Absolutely"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e0eeb94a-ce08-4b74-bc46-678a081d3aab"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e0eeb94a-ce08-4b74-bc46-678a081d3aab/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e0eeb94a-ce08-4b74-bc46-678a081d3aab/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8/rect","body":{},"result":{"value":{"height":40,"width":98,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action22","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action22","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f9fc9b57-13bb-4a90-8b6f-fd898f13ffe8/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/75a54188-4e7a-4f1b-8115-e0b976639f44/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/75a54188-4e7a-4f1b-8115-e0b976639f44/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/75a54188-4e7a-4f1b-8115-e0b976639f44/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/75a54188-4e7a-4f1b-8115-e0b976639f44/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e773f99f-b1e8-4d9b-9be5-9a5daed26eb8/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e773f99f-b1e8-4d9b-9be5-9a5daed26eb8/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/16b67e25-9a41-4f47-9c24-a7a394cccf98/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/16b67e25-9a41-4f47-9c24-a7a394cccf98/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/16b67e25-9a41-4f47-9c24-a7a394cccf98/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/16b67e25-9a41-4f47-9c24-a7a394cccf98/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/16b67e25-9a41-4f47-9c24-a7a394cccf98/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/16b67e25-9a41-4f47-9c24-a7a394cccf98/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/16b67e25-9a41-4f47-9c24-a7a394cccf98/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/16b67e25-9a41-4f47-9c24-a7a394cccf98/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3ba72f28-b6ae-490d-a96f-8bc5037b7c1e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3ba72f28-b6ae-490d-a96f-8bc5037b7c1e/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"8","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:15:12.867Z","end":"2023-02-17T02:15:18.867Z","_duration":6000,"uid":"83","cid":"0-0","title":"And I choose chat option \"Great!\"","fullTitle":"8: And I choose chat option \"Great!\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522","ELEMENT":"3b6156b9-00e7-4822-af26-631f36a9c522"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522","ELEMENT":"3b6156b9-00e7-4822-af26-631f36a9c522"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522","ELEMENT":"3b6156b9-00e7-4822-af26-631f36a9c522"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522","ELEMENT":"3b6156b9-00e7-4822-af26-631f36a9c522"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"},{"element-6066-11e4-a52e-4f735466cecf":"e773f99f-b1e8-4d9b-9be5-9a5daed26eb8"},{"element-6066-11e4-a52e-4f735466cecf":"3ba72f28-b6ae-490d-a96f-8bc5037b7c1e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3b6156b9-00e7-4822-af26-631f36a9c522/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3b6156b9-00e7-4822-af26-631f36a9c522/text","body":{},"result":{"value":"Great!"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e0eeb94a-ce08-4b74-bc46-678a081d3aab"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e0eeb94a-ce08-4b74-bc46-678a081d3aab/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e0eeb94a-ce08-4b74-bc46-678a081d3aab/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3b6156b9-00e7-4822-af26-631f36a9c522/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3b6156b9-00e7-4822-af26-631f36a9c522/rect","body":{},"result":{"value":{"height":40,"width":70,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action23","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action23","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"3b6156b9-00e7-4822-af26-631f36a9c522"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/3b6156b9-00e7-4822-af26-631f36a9c522/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/3b6156b9-00e7-4822-af26-631f36a9c522/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e773f99f-b1e8-4d9b-9be5-9a5daed26eb8/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e773f99f-b1e8-4d9b-9be5-9a5daed26eb8/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e773f99f-b1e8-4d9b-9be5-9a5daed26eb8/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e773f99f-b1e8-4d9b-9be5-9a5daed26eb8/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1ecd592b-0335-4f80-b038-1e548051552a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1ecd592b-0335-4f80-b038-1e548051552a/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3ba72f28-b6ae-490d-a96f-8bc5037b7c1e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3ba72f28-b6ae-490d-a96f-8bc5037b7c1e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3ba72f28-b6ae-490d-a96f-8bc5037b7c1e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3ba72f28-b6ae-490d-a96f-8bc5037b7c1e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3ba72f28-b6ae-490d-a96f-8bc5037b7c1e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3ba72f28-b6ae-490d-a96f-8bc5037b7c1e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3ba72f28-b6ae-490d-a96f-8bc5037b7c1e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3ba72f28-b6ae-490d-a96f-8bc5037b7c1e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9e4827c2-0b54-4081-9d68-87dd2f13953e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9e4827c2-0b54-4081-9d68-87dd2f13953e/text","body":{},"result":{"value":"Go!"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"8","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:15:18.868Z","end":"2023-02-17T02:15:23.744Z","_duration":4876,"uid":"84","cid":"0-0","title":"And I choose chat option \"Go!\"","fullTitle":"8: And I choose chat option \"Go!\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e","ELEMENT":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e","ELEMENT":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e","ELEMENT":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e","ELEMENT":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"},{"element-6066-11e4-a52e-4f735466cecf":"1ecd592b-0335-4f80-b038-1e548051552a"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9e4827c2-0b54-4081-9d68-87dd2f13953e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9e4827c2-0b54-4081-9d68-87dd2f13953e/text","body":{},"result":{"value":"Go!"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e0eeb94a-ce08-4b74-bc46-678a081d3aab"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e0eeb94a-ce08-4b74-bc46-678a081d3aab/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e0eeb94a-ce08-4b74-bc46-678a081d3aab/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9e4827c2-0b54-4081-9d68-87dd2f13953e/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9e4827c2-0b54-4081-9d68-87dd2f13953e/rect","body":{},"result":{"value":{"height":40,"width":64,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action24","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action24","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"9e4827c2-0b54-4081-9d68-87dd2f13953e"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9e4827c2-0b54-4081-9d68-87dd2f13953e/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9e4827c2-0b54-4081-9d68-87dd2f13953e/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1ecd592b-0335-4f80-b038-1e548051552a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"},{"element-6066-11e4-a52e-4f735466cecf":"6de9db89-f4e9-43ef-ba68-64b00fe606e4"},{"element-6066-11e4-a52e-4f735466cecf":"ddbd4de2-9619-4c76-8ea7-ebae60f95006"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1ecd592b-0335-4f80-b038-1e548051552a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"},{"element-6066-11e4-a52e-4f735466cecf":"6de9db89-f4e9-43ef-ba68-64b00fe606e4"},{"element-6066-11e4-a52e-4f735466cecf":"ddbd4de2-9619-4c76-8ea7-ebae60f95006"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1ecd592b-0335-4f80-b038-1e548051552a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"},{"element-6066-11e4-a52e-4f735466cecf":"6de9db89-f4e9-43ef-ba68-64b00fe606e4"},{"element-6066-11e4-a52e-4f735466cecf":"ddbd4de2-9619-4c76-8ea7-ebae60f95006"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1ecd592b-0335-4f80-b038-1e548051552a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"},{"element-6066-11e4-a52e-4f735466cecf":"6de9db89-f4e9-43ef-ba68-64b00fe606e4"},{"element-6066-11e4-a52e-4f735466cecf":"ddbd4de2-9619-4c76-8ea7-ebae60f95006"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6de9db89-f4e9-43ef-ba68-64b00fe606e4/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/6de9db89-f4e9-43ef-ba68-64b00fe606e4/text","body":{},"result":{"value":"Feature 2"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"8","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:15:23.745Z","end":"2023-02-17T02:15:23.775Z","_duration":30,"uid":"85","cid":"0-0","title":"Then the chatbot lists feature \"Natural Language Processing or just NLP\"","fullTitle":"8: Then the chatbot lists feature \"Natural Language Processing or just NLP\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0","ELEMENT":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0","ELEMENT":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0","ELEMENT":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0","ELEMENT":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__body"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__body"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"2da1124b-2cb2-4f24-a5b1-393ba4e6fd6a"},{"element-6066-11e4-a52e-4f735466cecf":"9c385a87-41fb-4217-84b6-77dada07e73b"},{"element-6066-11e4-a52e-4f735466cecf":"532658de-c89a-4e10-b024-a60cf99ec760"},{"element-6066-11e4-a52e-4f735466cecf":"86c3da71-c0ca-46fb-90c5-b7cde2a9a804"},{"element-6066-11e4-a52e-4f735466cecf":"ea29a7d0-6161-4166-b931-a70f3f9c106d"},{"element-6066-11e4-a52e-4f735466cecf":"5627968b-719c-4e9f-b05f-093b6dbc32ba"},{"element-6066-11e4-a52e-4f735466cecf":"90a990d0-74fd-43e6-9ab2-1a9d4815a07e"},{"element-6066-11e4-a52e-4f735466cecf":"5e6e63b8-c291-4108-aeba-9408f8cb97c9"},{"element-6066-11e4-a52e-4f735466cecf":"211f43f2-97d0-472e-8345-1ccb10d92df6"},{"element-6066-11e4-a52e-4f735466cecf":"1ef28e97-60e2-476b-8ad9-1c6e54f69367"},{"element-6066-11e4-a52e-4f735466cecf":"0fad5a93-8543-444a-9c41-d54626a4b119"},{"element-6066-11e4-a52e-4f735466cecf":"83c875cd-02c5-4463-9ae7-91ec8dccc3d1"},{"element-6066-11e4-a52e-4f735466cecf":"9d28a29a-71a4-4b90-99fc-b947dcf63e4d"},{"element-6066-11e4-a52e-4f735466cecf":"c28841af-e5ab-4330-9c81-ef8ae91fa5aa"},{"element-6066-11e4-a52e-4f735466cecf":"81621fd1-f0b1-4a85-b9ed-ee5db8b9ada1"},{"element-6066-11e4-a52e-4f735466cecf":"0937c2af-2822-40ef-a1e0-ed4e7b5b7ae6"},{"element-6066-11e4-a52e-4f735466cecf":"8a6de678-788b-43e2-9ac4-e18fe025887a"},{"element-6066-11e4-a52e-4f735466cecf":"0a53c3da-196c-4705-86ff-5f80b3ca61af"},{"element-6066-11e4-a52e-4f735466cecf":"a361689f-1644-40ac-93ee-3203b60a6914"},{"element-6066-11e4-a52e-4f735466cecf":"2f208d75-574e-4cbf-bc78-13048c18691d"},{"element-6066-11e4-a52e-4f735466cecf":"6610b370-442e-4565-b932-1dfe4b03e1b3"},{"element-6066-11e4-a52e-4f735466cecf":"d680a926-61e3-4598-8998-a150005c3fed"},{"element-6066-11e4-a52e-4f735466cecf":"d8512bf8-50ed-440a-8f40-6fd12ff89ba1"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d8512bf8-50ed-440a-8f40-6fd12ff89ba1/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d8512bf8-50ed-440a-8f40-6fd12ff89ba1/text","body":{},"result":{"value":"Natural Language Processing or just NLP"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"8","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:15:23.775Z","end":"2023-02-17T02:15:28.748Z","_duration":4973,"uid":"86","cid":"0-0","title":"And I choose chat option \"More\"","fullTitle":"8: And I choose chat option \"More\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0","ELEMENT":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0","ELEMENT":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0","ELEMENT":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0","ELEMENT":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"},{"element-6066-11e4-a52e-4f735466cecf":"6de9db89-f4e9-43ef-ba68-64b00fe606e4"},{"element-6066-11e4-a52e-4f735466cecf":"ddbd4de2-9619-4c76-8ea7-ebae60f95006"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a05f0b34-4d1c-4643-8f09-4b60301eadb0/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a05f0b34-4d1c-4643-8f09-4b60301eadb0/text","body":{},"result":{"value":"More"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"html"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e0eeb94a-ce08-4b74-bc46-678a081d3aab"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e0eeb94a-ce08-4b74-bc46-678a081d3aab/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e0eeb94a-ce08-4b74-bc46-678a081d3aab/rect","body":{},"result":{"value":{"height":600,"width":600,"x":0,"y":0}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a05f0b34-4d1c-4643-8f09-4b60301eadb0/rect","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a05f0b34-4d1c-4643-8f09-4b60301eadb0/rect","body":{},"result":{"value":{"height":40,"width":65,"x":70,"y":448}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action25","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}}]}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"id":"action25","type":"wheel","parameters":{},"actions":[{"type":"scroll","x":0,"y":0,"deltaX":280,"deltaY":280,"duration":200,"origin":{"element-6066-11e4-a52e-4f735466cecf":"a05f0b34-4d1c-4643-8f09-4b60301eadb0"}}]}]},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a05f0b34-4d1c-4643-8f09-4b60301eadb0/click","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a05f0b34-4d1c-4643-8f09-4b60301eadb0/click","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6de9db89-f4e9-43ef-ba68-64b00fe606e4/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".message__suggested-btn\"}\n  (Session info: chrome=110.0.5481.77)","stacktrace":"0   chromedriver                        0x00000001052991c0 chromedriver + 4248000\n1   chromedriver                        0x0000000105219dc0 chromedriver + 3726784\n2   chromedriver                        0x0000000104eceec4 chromedriver + 274116\n3   chromedriver                        0x0000000104f0abe4 chromedriver + 519140\n4   chromedriver                        0x0000000104f46054 chromedriver + 761940\n5   chromedriver                        0x0000000104efd200 chromedriver + 463360\n6   chromedriver                        0x0000000104efe318 chromedriver + 467736\n7   chromedriver                        0x0000000105267060 chromedriver + 4042848\n8   chromedriver                        0x000000010526b8a4 chromedriver + 4061348\n9   chromedriver                        0x00000001052733d0 chromedriver + 4092880\n10  chromedriver                        0x000000010526c6e4 chromedriver + 4064996\n11  chromedriver                        0x00000001052420fc chromedriver + 3891452\n12  chromedriver                        0x000000010528ca64 chromedriver + 4196964\n13  chromedriver                        0x000000010528cbb8 chromedriver + 4197304\n14  chromedriver                        0x00000001052a0650 chromedriver + 4277840\n15  libsystem_pthread.dylib             0x00000001afdbd06c _pthread_start + 148\n16  libsystem_pthread.dylib             0x00000001afdb7e2c thread_start + 8\n"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"},{"element-6066-11e4-a52e-4f735466cecf":"c003da0e-9242-4d4e-b505-aaf81513d373"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6de9db89-f4e9-43ef-ba68-64b00fe606e4/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"},{"element-6066-11e4-a52e-4f735466cecf":"c003da0e-9242-4d4e-b505-aaf81513d373"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6de9db89-f4e9-43ef-ba68-64b00fe606e4/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"},{"element-6066-11e4-a52e-4f735466cecf":"c003da0e-9242-4d4e-b505-aaf81513d373"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6de9db89-f4e9-43ef-ba68-64b00fe606e4/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"},{"element-6066-11e4-a52e-4f735466cecf":"c003da0e-9242-4d4e-b505-aaf81513d373"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c003da0e-9242-4d4e-b505-aaf81513d373/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c003da0e-9242-4d4e-b505-aaf81513d373/text","body":{},"result":{"value":"No"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ddbd4de2-9619-4c76-8ea7-ebae60f95006/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"},{"element-6066-11e4-a52e-4f735466cecf":"c003da0e-9242-4d4e-b505-aaf81513d373"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ddbd4de2-9619-4c76-8ea7-ebae60f95006/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"},{"element-6066-11e4-a52e-4f735466cecf":"c003da0e-9242-4d4e-b505-aaf81513d373"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ddbd4de2-9619-4c76-8ea7-ebae60f95006/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"},{"element-6066-11e4-a52e-4f735466cecf":"c003da0e-9242-4d4e-b505-aaf81513d373"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ddbd4de2-9619-4c76-8ea7-ebae60f95006/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"},{"element-6066-11e4-a52e-4f735466cecf":"c003da0e-9242-4d4e-b505-aaf81513d373"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ddbd4de2-9619-4c76-8ea7-ebae60f95006/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"},{"element-6066-11e4-a52e-4f735466cecf":"c003da0e-9242-4d4e-b505-aaf81513d373"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ddbd4de2-9619-4c76-8ea7-ebae60f95006/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"},{"element-6066-11e4-a52e-4f735466cecf":"c003da0e-9242-4d4e-b505-aaf81513d373"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ddbd4de2-9619-4c76-8ea7-ebae60f95006/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"},{"element-6066-11e4-a52e-4f735466cecf":"c003da0e-9242-4d4e-b505-aaf81513d373"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ddbd4de2-9619-4c76-8ea7-ebae60f95006/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"},{"element-6066-11e4-a52e-4f735466cecf":"c003da0e-9242-4d4e-b505-aaf81513d373"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/46e514e9-880a-4d02-a550-a3416e60d438/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/46e514e9-880a-4d02-a550-a3416e60d438/text","body":{},"result":{"value":"Yes"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"8","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2023-02-17T02:15:28.748Z","end":"2023-02-17T02:15:28.927Z","_duration":179,"uid":"87","cid":"0-0","title":"Then the chatbox explains the feature, \"NLP means that the chatbot can process what someone tells it in natural language and determine what is the intent of the other party and what objects or entities are involved.\"","fullTitle":"8: Then the chatbox explains the feature, \"NLP means that the chatbot can process what someone tells it in natural language and determine what is the intent of the other party and what objects or entities are involved.\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".message__suggested-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438"}},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438","ELEMENT":"46e514e9-880a-4d02-a550-a3416e60d438"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        const boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438","ELEMENT":"46e514e9-880a-4d02-a550-a3416e60d438"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438","ELEMENT":"46e514e9-880a-4d02-a550-a3416e60d438"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            const shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"46e514e9-880a-4d02-a550-a3416e60d438","ELEMENT":"46e514e9-880a-4d02-a550-a3416e60d438"}]},"result":{"value":true},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__body"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".message__body"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"2da1124b-2cb2-4f24-a5b1-393ba4e6fd6a"},{"element-6066-11e4-a52e-4f735466cecf":"9c385a87-41fb-4217-84b6-77dada07e73b"},{"element-6066-11e4-a52e-4f735466cecf":"532658de-c89a-4e10-b024-a60cf99ec760"},{"element-6066-11e4-a52e-4f735466cecf":"86c3da71-c0ca-46fb-90c5-b7cde2a9a804"},{"element-6066-11e4-a52e-4f735466cecf":"ea29a7d0-6161-4166-b931-a70f3f9c106d"},{"element-6066-11e4-a52e-4f735466cecf":"5627968b-719c-4e9f-b05f-093b6dbc32ba"},{"element-6066-11e4-a52e-4f735466cecf":"90a990d0-74fd-43e6-9ab2-1a9d4815a07e"},{"element-6066-11e4-a52e-4f735466cecf":"5e6e63b8-c291-4108-aeba-9408f8cb97c9"},{"element-6066-11e4-a52e-4f735466cecf":"211f43f2-97d0-472e-8345-1ccb10d92df6"},{"element-6066-11e4-a52e-4f735466cecf":"1ef28e97-60e2-476b-8ad9-1c6e54f69367"},{"element-6066-11e4-a52e-4f735466cecf":"0fad5a93-8543-444a-9c41-d54626a4b119"},{"element-6066-11e4-a52e-4f735466cecf":"83c875cd-02c5-4463-9ae7-91ec8dccc3d1"},{"element-6066-11e4-a52e-4f735466cecf":"9d28a29a-71a4-4b90-99fc-b947dcf63e4d"},{"element-6066-11e4-a52e-4f735466cecf":"c28841af-e5ab-4330-9c81-ef8ae91fa5aa"},{"element-6066-11e4-a52e-4f735466cecf":"81621fd1-f0b1-4a85-b9ed-ee5db8b9ada1"},{"element-6066-11e4-a52e-4f735466cecf":"0937c2af-2822-40ef-a1e0-ed4e7b5b7ae6"},{"element-6066-11e4-a52e-4f735466cecf":"8a6de678-788b-43e2-9ac4-e18fe025887a"},{"element-6066-11e4-a52e-4f735466cecf":"0a53c3da-196c-4705-86ff-5f80b3ca61af"},{"element-6066-11e4-a52e-4f735466cecf":"a361689f-1644-40ac-93ee-3203b60a6914"},{"element-6066-11e4-a52e-4f735466cecf":"2f208d75-574e-4cbf-bc78-13048c18691d"},{"element-6066-11e4-a52e-4f735466cecf":"6610b370-442e-4565-b932-1dfe4b03e1b3"},{"element-6066-11e4-a52e-4f735466cecf":"d680a926-61e3-4598-8998-a150005c3fed"},{"element-6066-11e4-a52e-4f735466cecf":"d8512bf8-50ed-440a-8f40-6fd12ff89ba1"},{"element-6066-11e4-a52e-4f735466cecf":"48d34b9f-d85b-4641-86bf-68267e12c44b"},{"element-6066-11e4-a52e-4f735466cecf":"19030921-c790-4be2-8a87-c8828ba04daa"},{"element-6066-11e4-a52e-4f735466cecf":"84a39ccd-8452-49fd-83c6-4315683e6f56"}]},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2da1124b-2cb2-4f24-a5b1-393ba4e6fd6a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/2da1124b-2cb2-4f24-a5b1-393ba4e6fd6a/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9c385a87-41fb-4217-84b6-77dada07e73b/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9c385a87-41fb-4217-84b6-77dada07e73b/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/532658de-c89a-4e10-b024-a60cf99ec760/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/532658de-c89a-4e10-b024-a60cf99ec760/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/86c3da71-c0ca-46fb-90c5-b7cde2a9a804/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/86c3da71-c0ca-46fb-90c5-b7cde2a9a804/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ea29a7d0-6161-4166-b931-a70f3f9c106d/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ea29a7d0-6161-4166-b931-a70f3f9c106d/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5627968b-719c-4e9f-b05f-093b6dbc32ba/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5627968b-719c-4e9f-b05f-093b6dbc32ba/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/90a990d0-74fd-43e6-9ab2-1a9d4815a07e/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/90a990d0-74fd-43e6-9ab2-1a9d4815a07e/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5e6e63b8-c291-4108-aeba-9408f8cb97c9/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5e6e63b8-c291-4108-aeba-9408f8cb97c9/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/211f43f2-97d0-472e-8345-1ccb10d92df6/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/211f43f2-97d0-472e-8345-1ccb10d92df6/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1ef28e97-60e2-476b-8ad9-1c6e54f69367/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1ef28e97-60e2-476b-8ad9-1c6e54f69367/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0fad5a93-8543-444a-9c41-d54626a4b119/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0fad5a93-8543-444a-9c41-d54626a4b119/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/83c875cd-02c5-4463-9ae7-91ec8dccc3d1/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/83c875cd-02c5-4463-9ae7-91ec8dccc3d1/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9d28a29a-71a4-4b90-99fc-b947dcf63e4d/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9d28a29a-71a4-4b90-99fc-b947dcf63e4d/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c28841af-e5ab-4330-9c81-ef8ae91fa5aa/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c28841af-e5ab-4330-9c81-ef8ae91fa5aa/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/81621fd1-f0b1-4a85-b9ed-ee5db8b9ada1/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/81621fd1-f0b1-4a85-b9ed-ee5db8b9ada1/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0937c2af-2822-40ef-a1e0-ed4e7b5b7ae6/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0937c2af-2822-40ef-a1e0-ed4e7b5b7ae6/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8a6de678-788b-43e2-9ac4-e18fe025887a/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8a6de678-788b-43e2-9ac4-e18fe025887a/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0a53c3da-196c-4705-86ff-5f80b3ca61af/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0a53c3da-196c-4705-86ff-5f80b3ca61af/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a361689f-1644-40ac-93ee-3203b60a6914/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a361689f-1644-40ac-93ee-3203b60a6914/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2f208d75-574e-4cbf-bc78-13048c18691d/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/2f208d75-574e-4cbf-bc78-13048c18691d/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6610b370-442e-4565-b932-1dfe4b03e1b3/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/6610b370-442e-4565-b932-1dfe4b03e1b3/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d680a926-61e3-4598-8998-a150005c3fed/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d680a926-61e3-4598-8998-a150005c3fed/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d8512bf8-50ed-440a-8f40-6fd12ff89ba1/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d8512bf8-50ed-440a-8f40-6fd12ff89ba1/text","body":{},"result":{"value":""},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/48d34b9f-d85b-4641-86bf-68267e12c44b/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/48d34b9f-d85b-4641-86bf-68267e12c44b/text","body":{},"result":{"value":"More"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/19030921-c790-4be2-8a87-c8828ba04daa/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/19030921-c790-4be2-8a87-c8828ba04daa/text","body":{},"result":{"value":"NLP means that the chatbot can process what someone tells it in natural language and determine what is the intent of the other party and what objects or entities are involved."},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/84a39ccd-8452-49fd-83c6-4315683e6f56/text","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/84a39ccd-8452-49fd-83c6-4315683e6f56/text","body":{},"result":{"value":"John, would you like an example?"},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"182497dc6bf76af7c5a842405e9ac3c5","cid":"0-0","type":"result"}],"retries":0,"parent":"8","state":"passed","events":[],"errorIndex":0},{"type":"hook","start":"2023-02-17T02:15:28.927Z","end":"2023-02-17T02:15:28.927Z","_duration":0,"uid":"174","cid":"0-0","title":"","parent":"8","errors":[]}]}],"hooksAndTests":[],"description":""}],"reportFile":"/Users/jimwatkins/Workspace/fart/reports/html-reports/report-0-0.html","browserName":"not specified"}